<h1><b>Lazy-Lists and Continuation Passing Style (CPS)</b></h1>

<h2><b>Practical Session - Week #10</b></h2>

# Lists-Lazy

תזכורת: רשימות עצלות הן מבני נתונים סדרתיים המאפשרים דחייה של חישוב ושמירה של איברים מתוכם.
היתרונות בשימוש בהן:
* אין צורך לאחסן בזיכרון את כל איברי הרשימה. בעזרת רשימות עצלות ניתן לייצג אף סדרות אינסופיות.
* דחיית חישוב איברים ברשימה לזמן בו נדקק להם – ייתכן שלא נזדקק לכל איברי הרשימה.

נגדיר את ערכי הטיפוס של רשימות עצלות באופן רקורסיבי:

```typescript
LzL = { empty-lzl } ∪ (Scheme-Type × [Empty → LzL])
```
זהו ADT עבור רשימות עצלות (המימוש מופיע בספר הקורס):

```typescript
; Signature: cons-lzl(x, f)
; Type: [T * [Empty -> LzL] -> LzL]

; Signature: head(lz-list)
; Type: [LzL -> T]
; Pre-condition: non-empty LzL

; Signature: tail(lz-list)
; Type: [LzL -> LzL]
; Pre-condition: non-empty LzL

; Signature: empty-lzl?(exp)
; Type: [T -> Boolean]

; Signature: nth(lz-list, n)
; Type: [LzL * Number -> T]

; Signature: take(lz-list, n)
; Type: [LzL * Number -> List]
```

## שאלה 1 – השערת קולץ
נגדיר את הפונקציה:

<div align="center">
<img src="https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/resources/ps10/collatz%20exmple.png" align="center" border="0" alt="\[f(n)=\begin{cases}n/2, & \text{n is even}\\3n+1&\text{n is odd}\end{cases}\]" width="214" height="50" />
</div>


השערת קולץ גורסת כי לכל n>1 מתקיים כי הסדרה n,f(n),f(f(n)),f(f(f(n)))… תמיד מתכנסת ב-1. 
למשל עבור n=563: 

563 -> 1690 -> 845 -> 2536 -> 1268 -> 634 -> 317 -> 952 -> 476 -> 238 -> 119 -> 358 -> 179 -> 538 -> 269 -> 808 -> 404 -> 202 -> 101 -> 304 -> 152 -> 76 -> 38 -> 19 -> 58 -> 29 -> 88 -> 44 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

נרצה להגדיר את הרשימה העצלה המכילה את סדרת קולץ עבור n כלשהו.

```typescript
; Signature: lzl-collatz(n)
; Type: [Number -> LzL(Number)]
; Purpose: Generate the (possibly infinite) series { n, f(n), f(f(n)), ... },
; where f(n) is collatz function
; Pre-condition: n is a natural number greater than zero
(define lzl-collatz
    (lambda (n)
        (if (< n 2)
            (cons-lzl n (lambda () empty-lzl))
            (cons-lzl n
                (lambda ()
                    (if (= (modulo n 2) 0)
                        (lzl-collatz (/ n 2))
                        (lzl-collatz (+ (* 3 n) 1))))))))
> (take (lzl-collatz 563) 44)
'(563 1690 845 2536 1268 634 317 952 476 238 119 358 179 538 269 808 404 202
101 304 152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)
```
מה הטיפוס של lzl-collatz? האם הפרוצדורה היא well-typed? האם ```(head (lzl-collatz n))``` עבור n טבעי כלשהי תמיד תצליח?


## שאלה 2 – סדרת ההפעלות העצמיות

בהינתן פונקציה ![equation 1](https://render.githubusercontent.com/render/math?math=f) וערך ![equation 2](https://render.githubusercontent.com/render/math?math=x) , נגדיר את סדרת ההרכבות העצמיות להיות ![equation 3](http://www.sciweavers.org/tex2img.php?eq=%20%5C%7Bx%2Cf(x)%2Cf(f(x))%2Cf(f(f(x)))%2C...%5C%7D&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=) . הסדרה
יכולה להיות סופית, או אינסופית. נרצה לייצר את הרשימה העצלה שאיבריה הם איברי הסדרה. הרשימה תיגמר כאשר
הגיעה לנקודת שבת, כלומר כאשר הערך המוחזר מהפעלת ![equation 4](https://render.githubusercontent.com/render/math?math=f) הוא אותו הערך שעליו ![equation 5](https://render.githubusercontent.com/render/math?math=f) הופעלה.

```typescript
; Signature: lzl-apply(f, x)
; Type: [[T -> T] * T -> LzL]
; Purpose: Generate the self-application series of f on x
(define lzl-apply
    (lambda (f x)
        (let ((fx (f x)))
            (if (= fx x)
                (cons-lzl x (lambda () empty-lzl))
                (cons-lzl x (lambda () (lzl-apply f fx)))))))
> (take (lzl-apply (lambda (x) (+ 1 (/ 1 x))) 1.0) 100)
'(1.0 2.0 1.5 1.6666666666666665 1.6 1.625 ... 1.6180339887498951)
                             𝑙𝑒𝑛𝑔𝑡ℎ = 38

> (take (lzl-apply (lambda (x) x) 1) 100)
'(1)

```
# Continuation Passing Style (CPS) 

פרדיגמה תכנותית בה לכל פרוצדורת משתמש ניתן פרמטר נוסף שהינו פרוצדורה, אשר מהווה את המשך החישוב שיש לבצע בתום פעולת פרוצדורת המשתמש (ועל כן נקרא הפרמטר continuation). חלק מן המוטיבציה לשימוש בפרדיגמת תכנות זו היא השליטה שהיא מאפשרת בבקרה של התוכנית:

1.	במהלך כתיבת פרוצדורות משתמש בשיטת CPS, כל קריאה רקורסיבית נכתבת כך שהיא בעמדת זנב. לכן, מעצם השימוש בשיטה, הפרוצדורה תייצר תהליך איטרטיבי.
2. שיטת	CPS מאפשרת לשלוט בסדר לפיו התוכנית תחשב ביטויים. למשל, אם נממש חיפוש בעץ, נוכל לבחור אם לחפש קודם בענף הימני או בשמאלי (לעומת זאת, ללא CPS נהייה תלויים בסדר הערכת הביטויים המובנה ב-interpreter).
3.	השליטה בבקרת התוכנית מאפשרת לנקוט בפעולה שונה במקרה של הצלחה / כישלון או יציאה ישירה (exception) במהלך רקורסיה (או איטרציה) וכן מאפשרת להחזיר כמה ערכים ביחד. 

## שאלה 1 – אופן פעולת פרוצדורה בגרסת CPS והוכחת נכונות

ניזכר במימוש של הפרוצדורה fact ללא שימוש ב-CPS:


```typescript
; Type: [Number -> Number]
; Purpose: To calculate the factorial of n.
(define fact
    (lambda (n)
        (if (= n 0)
            1
            (* n (fact (- n 1))))))
```
כעת, נממש את fact בשיטת CPS ונמחיש את אופן הפעולה שלה:
```typescript
; Type: [Number * [Number->T1] -> T1]
; Purpose: Returns the application of the
; continuation c on the factorial of n.
(define fact$
    (lambda (n c)
        (if (= n 0)
            (c 1)
            (fact$ (- n 1)
                (lambda (fact_n-1)
                    (c (* n fact_n-1)))))))
> (fact 5)
120
> (fact$ 5 add1)
121
```
דיון: מדוע התוצאות אינן זהות? כיצד נרצה לקבוע בדרך כלל את פרוצדורת ה-continuation שנעביר לקריאה הראשונה?

### הוכחת נכונות:
 לאחר המרת פרוצדורה לגרסת ה-CPS שלה, נדרשת הוכחת נכונות. הנכונות נשענת על הצגת שקילות בין שתי הגרסאות, במובן הבא: בהפעלת האלגוריתם applicative-eval על קריאה מתאימה לכל אחת מן הגרסאות, החישוב יסתיים ויוחזר ערך זהה. לשם כך, נזדקק להגדרת השקילות הבאה:

הגדרה: פרוצדורה \$f שקולה-CPS לפרוצדורה f אם לכל ערכי קלט x1,x2,…,x3 ולכל continuation המסומן cont, מתקיים:
```typescript
(f$ x1 … xn cont) = (cont (f x1 … xn))
```
טענה: הפרוצדורה \$fact שקולה-CPS לפרוצדורה fact. כלומר, לכל מספר טבעי, n, ולכל continuation, אשר יסומן על ידי c, מתקיים:  
```typescript
(fact$ n c) = (c (fact n))
```
הוכחה: כיוון שהפרוצדורה fact היא רקורסיבית, ההוכחה מתבצעת על ידי שימוש באינדוקציה.

בסיס האינדוקציה: n=0
```typescript
a-e[ (fact$ 0 c) ] ==>* a-e[ (c 1) ] = a-e[ (c (fact 0)) ]
```
(הסימון a-e הוא קיצור עבור applicative-eval)

הנחת האינדוקציה: עבור n=k∈ N הטענה מתקיימת לכל k≥i. כלומר
```typescript
(fact$ i c) = (c (fact i))
```
צעד האינדוקציה: יהא n=k+1,k∈N, אזי:
```typescript
a-e [ (fact$ n c) ] ==>*
a-e [ (fact$ (- n 1) (lambda (res) (c (* n res)))) ] ==>*
```

מהנחת האינדוקציה, נקבל:
```typescript
a-e [ ((lambda (res) (c (* n res))) (fact (- n 1))) ] ==>*
a-e [ (c (* n (fact (- n 1)))) ] =
a-e [ (c (fact n)) ]
```


## כללי אצבע להמרת פרוצדורה רקורסיבית לפרוצדורה שקולה-CPS:

בהינתן פרוצדורה רקורסיבית, f, עם הפרמטרים הפורמאליים x1,…,xn, פרוצדורה שקולה-CPS לה תסומן \$f ותופעל על ארגומנט נוסף, c, ה-continuation. העקרונות שינחו אותנו בכתיבת \$f הם כדלקמן:

א.	נפעיל את c על ערכים מוחזרים (כחלק ממקרה הבסיס, או בתוך continuation הנוצר במהלך הריצה). 

ב.	נקפיד לכתוב כל קריאה לפרוצדורת משתמש בתוך \$f כך שהקריאה תהיה בעמדת זנב.

ג.	כתיבת ה-continuation:
a.	כשנבצע בתוך \$f קריאה רקורסיבית כלשהי  עם ארגומנטים x1,…,xn, נתבסס על הנחת האינדוקציה (המקטינה את הבעיה). כלומר, נניח כי התשובה עבור הבעיה המוקטנת מתקבלת כארגומנט של
ה-continuation.
b.	בכתיבת ה-continuation, נקיים את צעד האינדוקציה ונפעל על הפתרון עבור הבעיה המוקטנת כדי לקבל את הפתרון לבעיה הגדולה יותר.

ד.	בכתיבת פרוצדורה בשיטת CPS, נקפיד שכל פרוצדורת משתמש (לא פרימיטיבית) המשמשת את \$f תהיה גם היא כתובה בשיטת CPS.
ה.	בדרך כלל, לא נרצה לבצע מניפולציה על הערך המוחזר של הפונקציה ולכן נשתמש בפונקציית הזהות id
כ-continuation ההתחלתי.

## שאלה 2 – פונקציות CPS מסדר גבוה

נמיר את הפונקציה foldr ל-CPS. תזכורת:

<div align="center">

```typescript
(foldr op initial (list x1 x2 ... xn))
⇕
(op x1 (op x2 (op ... (op xn initial))))
```

</div>

```typescript
; Signature: foldr(op, initial, sequence)
; Type: [ [ T1 * T2 -> T2 ] * T2 * List(T1) -> T2 ]
; Example: (foldr + 0 (list 1 2 3 4 5)) => 15
(define foldr
  (lambda (op initial sequence)
    (if (empty? sequence)
        initial
        (op (car sequence)
            (foldr op initial (cdr sequence)))))) 

; Signature: foldr$(op, initial, sequence, c)
; Type: [ [T1 * T2 -> T2] * T2 * List(T1) * [T2 -> T3] -> T3 ]
; Example: (foldr$ * 1 (list 1 2 3 4 5)
;                  (lambda (result) (cons 'the-product result)))
 ;          => '(the-product . 120)
(define foldr$
  (lambda (op initial sequence c)
    (if (empty? sequence)
        (c initial)
        (foldr$ op
                initial
                (cdr sequence)
                (lambda (acc-cdr-res)
                  (c (op (car sequence) acc-cdr-res)))))))

; Signature: foldr$$(op$, initial, sequence, c)
; Type: [ [T1 * T2 * [T2->T3] -> T3] * T2 * List(T1) * [T2->T3] -> T3 ]
; Example: (foldr$ +$ 0 (list 1 2 3 4 5) 
;                 (lambda (result) (cons 'the-sum result)))
;           => '(the-sum . 15)
(define foldr$$
  (lambda (op$ initial sequence c)
    (if (empty? sequence)
        (c initial)
        (foldr$$ op$ 
                 initial
                 (cdr sequence)
                 (lambda (acc-cdr-res)
                   (op$ (car sequence) acc-cdr-res c))))))

```
 

נשים לב: מדוע לא יכולנו להפעיל את c על תוצאת \$op במקום להעביר לה את c כארגומנט? ראשית, לו עשינו כך, הקריאה לא הייתה בעמדת זנב. בנוסף, הבעיה המהותית יותר היא שבמקרה כזה היינו מאבדים את השליטה על תהליך החישוב המגולמת בתוך ה-continuation. 

## שאלה 3 – עצירת החישוב
הפונקציה $list-mul מקבלת רשימה של רשימות ומחזירה מכפלה של כל המספרים ברשימה. אם יש מופע אטומי
שאינו מספר אז יש לעצור את החישוב.

![mul-list](https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/resources/ps10/mul-list.png)

## שאלה 4 – שימוש במספר continuations

לצורך הפשטת העבודה מול רשימות, נשתמש ב-ADT עבור עצים (המימוש מופיע בספר הקורס). כפי שכבר ראינו בעבר עבור רשימות ורשימות עצלות, גם עץ מוגדר בצורה רקורסיבית:
1.	Empty-Tree is a Tree
2.	if t is a Tree, than for every e: the value of  (add-subtree (make-leaf e) t) is a Tree

ממשק ה-ADT:

```typescript
; Signature: make-tree(1st, ..., nth)
; Type: [Tree * ... * Tree -> Tree]

; Signature: add-subtree(subtree, tree)
; Type: [Tree * Tree -> Tree]

; Signature: make-leaf(data)
; Type: [T -> Tree]

; Signature: empty-tree
; Type: Empty-Tree

; Signature: first-subtree(tree)
; Type: [Tree -> Tree]

; Signature: rest-subtrees(tree)
; Type: [Tree -> Tree]

; Signature: leaf-data(leaf)
; Type: [Tree -> T]

; Signature: composite-tree?(e)
; Type: [T -> Boolean]

; Signature: leaf?(e)
; Type: [T -> Boolean]

; Signature: empty-tree?(e)
; Type: [T -> Boolean]

```

הפונקציה \$replace-leaves מקבלת עץ הומוגני, פרדיקט (שאינו כתוב בגרסת CPS), ביטוי new מטיפוס עלי העץ ושני continuations: אחד עבור הצלחה והשני עבור כישלון. המטרה היא להחליף את כל העלים אשר מקיימים את הפרדיקט, בביטוי new. נשים לב שניתן להכליל את הקוד ע"י העברת פרוצדורה בתור new ולשנות את העלה בצורה דינמית.
 
![replace-leaves](https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/resources/ps10/replace-leaves.png)

```typescript
> (define tree (make-tree (make-tree (make-leaf 1) (make-leaf 2))
                          (make-tree (make-leaf 3) (make-leaf 4)
                                     (make-tree (make-leaf 5)))))

> (replace-leaves$ tree even? 42 (lambda (x) x) (lambda () tree))
'((1 42) (3 42 (5)))

```

הערה: יכולנו במקום succ ו-fail להעביר פרוצדורות שמבצעות מניפולציות אחרות על התוצאה – כל זאת מבלי לשנות שורה אחת בקוד הקיים של \$replace-leaves. לדוגמה:

```typescript
> (replace-leaves$ tree
                   (lambda (x) (> x 100))
                   42
                   (lambda (x) x)
                   (lambda ()
                     (replace-leaves$ tree
                                      odd?
                                      0
                                      permutations
                                      (lambda () 'I-give-up))))
'(((0 2) (0 4 (0))) ((0 4 (0)) (0 2)))

```
