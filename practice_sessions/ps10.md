<h1><b>Lazy-Lists and Continuation Passing Style (CPS)</b></h1>

<h2><b>Practical Session - Week #10</b></h2>

## Lists-Lazy

תזכורת: רשימות עצלות הן מבני נתונים סדרתיים המאפשרים דחייה של חישוב ושמירה של איברים מתוכם.
היתרונות בשימוש בהן:
* אין צורך לאחסן בזיכרון את כל איברי הרשימה. בעזרת רשימות עצלות ניתן לייצג אף סדרות אינסופיות.
* דחיית חישוב איברים ברשימה לזמן בו נדקק להם – ייתכן שלא נזדקק לכל איברי הרשימה.

נגדיר את ערכי הטיפוס של רשימות עצלות באופן רקורסיבי:

```typescript
LzL = { empty-lzl } ∪ (Scheme-Type × [Empty → LzL])
```
זהו ADT עבור רשימות עצלות (המימוש מופיע בספר הקורס):

```typescript
; Signature: cons-lzl(x, f)
; Type: [T * [Empty -> LzL] -> LzL]

; Signature: head(lz-list)
; Type: [LzL -> T]
; Pre-condition: non-empty LzL

; Signature: tail(lz-list)
; Type: [LzL -> LzL]
; Pre-condition: non-empty LzL

; Signature: empty-lzl?(exp)
; Type: [T -> Boolean]

; Signature: nth(lz-list, n)
; Type: [LzL * Number -> T]

; Signature: take(lz-list, n)
; Type: [LzL * Number -> List]
```

#### שאלה 1 – השערת קולץ
נגדיר את הפונקציה:

<p align="center">
<img src="https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/resources/ps10/collatz%20exmple.png" align="center" border="0" alt="\[f(n)=\begin{cases}n/2, & \text{n is even}\\3n+1&\text{n is odd}\end{cases}\]" width="214" height="50" />
</p>

השערת קולץ גורסת כי לכל n>1 מתקיים כי הסדרה n,f(n),f(f(n)),f(f(f(n)))… תמיד מתכנסת ב-1. למשל עבור n=563: 

563 -> 1690 -> 845 -> 2536 -> 1268 -> 634 -> 317 -> 952 -> 476 -> 238 -> 119 -> 358 -> 179 -> 538 -> 269 -> 808 -> 404 -> 202 -> 101 -> 304 -> 152 -> 76 -> 38 -> 19 -> 58 -> 29 -> 88 -> 44 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

נרצה להגדיר את הרשימה העצלה המכילה את סדרת קולץ עבור n כלשהו.

```typescript
; Signature: lzl-collatz(n)
; Type: [Number -> LzL(Number)]
; Purpose: Generate the (possibly infinite) series { n, f(n), f(f(n)), ... },
; where f(n) is collatz function
; Pre-condition: n is a natural number greater than zero
(define lzl-collatz
    (lambda (n)
        (if (< n 2)
            (cons-lzl n (lambda () empty-lzl))
            (cons-lzl n
                (lambda ()
                    (if (= (modulo n 2) 0)
                        (lzl-collatz (/ n 2))
                        (lzl-collatz (+ (* 3 n) 1))))))))
> (take (lzl-collatz 563) 44)
'(563 1690 845 2536 1268 634 317 952 476 238 119 358 179 538 269 808 404 202
101 304 152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)
```
מה הטיפוס של lzl-collatz? האם הפרוצדורה היא well-typed? האם ```(head (lzl-collatz n))``` עבור n טבעי כלשהי תמיד תצליח?


#### שאלה 2 – סדרת ההפעלות העצמיות

בהינתן פונקציה ![equation 1](https://render.githubusercontent.com/render/math?math=f) וערך ![equation 2](https://render.githubusercontent.com/render/math?math=x) , נגדיר את סדרת ההרכבות העצמיות להיות ![equation 3](http://www.sciweavers.org/tex2img.php?eq=%20%5C%7Bx%2Cf(x)%2Cf(f(x))%2Cf(f(f(x)))%2C...%5C%7D&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=) . הסדרה
יכולה להיות סופית, או אינסופית. נרצה לייצר את הרשימה העצלה שאיבריה הם איברי הסדרה. הרשימה תיגמר כאשר
הגיעה לנקודת שבת, כלומר כאשר הערך המוחזר מהפעלת ![equation 4](https://render.githubusercontent.com/render/math?math=f) הוא אותו הערך שעליו ![equation 5](https://render.githubusercontent.com/render/math?math=f) הופעלה.

```typescript
; Signature: lzl-apply(f, x)
; Type: [[T -> T] * T -> LzL]
; Purpose: Generate the self-application series of f on x
(define lzl-apply
    (lambda (f x)
        (let ((fx (f x)))
            (if (= fx x)
                (cons-lzl x (lambda () empty-lzl))
                (cons-lzl x (lambda () (lzl-apply f fx)))))))
> (take (lzl-apply (lambda (x) (+ 1 (/ 1 x))) 1.0) 100)
'(1.0 2.0 1.5 1.6666666666666665 1.6 1.625 ... 1.6180339887498951)
                             𝑙𝑒𝑛𝑔𝑡ℎ = 38

> (take (lzl-apply (lambda (x) x) 1) 100)
'(1)

```
## Continuation Passing Style (CPS) 

פרדיגמה תכנותית בה לכל פרוצדורת משתמש ניתן פרמטר נוסף שהינו פרוצדורה, אשר מהווה את המשך החישוב שיש לבצע בתום פעולת פרוצדורת המשתמש (ועל כן נקרא הפרמטר continuation). חלק מן המוטיבציה לשימוש בפרדיגמת תכנות זו היא השליטה שהיא מאפשרת בבקרה של התוכנית:

1.	במהלך כתיבת פרוצדורות משתמש בשיטת CPS, כל קריאה רקורסיבית נכתבת כך שהיא בעמדת זנב. לכן, מעצם השימוש בשיטה, הפרוצדורה תייצר תהליך איטרטיבי.
2. שיטת	CPS מאפשרת לשלוט בסדר לפיו התוכנית תחשב ביטויים. למשל, אם נממש חיפוש בעץ, נוכל לבחור אם לחפש קודם בענף הימני או בשמאלי (לעומת זאת, ללא CPS נהייה תלויים בסדר הערכת הביטויים המובנה ב-interpreter).
3.	השליטה בבקרת התוכנית מאפשרת לנקוט בפעולה שונה במקרה של הצלחה / כישלון או יציאה ישירה (exception) במהלך רקורסיה (או איטרציה) וכן מאפשרת להחזיר כמה ערכים ביחד. 


```typescript
; Type: [Number -> Number]
; Purpose: To calculate the factorial of n.
(define fact
    (lambda (n)
        (if (= n 0)
            1
            (* n (fact (- n 1))))))
```
כעת, נממש את fact בשיטת CPS ונמחיש את אופן הפעולה שלה:
```typescript
; Type: [Number * [Number->T1] -> T1]
; Purpose: Returns the application of the
; continuation c on the factorial of n.
(define fact$
    (lambda (n c)
        (if (= n 0)
            (c 1)
            (fact$ (- n 1)
                (lambda (fact_n-1)
                    (c (* n fact_n-1)))))))
> (fact 5)
120
> (fact$ 5 add1)
121
```
דיון: מדוע התוצאות אינן זהות? כיצד נרצה לקבוע בדרך כלל את פרוצדורת ה-continuation שנעביר לקריאה הראשונה?

הוכחת נכונות: לאחר המרת פרוצדורה לגרסת ה-CPS שלה, נדרשת הוכחת נכונות. הנכונות נשענת על הצגת שקילות בין שתי הגרסאות, במובן הבא: בהפעלת האלגוריתם applicative-eval על קריאה מתאימה לכל אחת מן הגרסאות, החישוב יסתיים ויוחזר ערך זהה. לשם כך, נזדקק להגדרת השקילות הבאה:

הגדרה: פרוצדורה f$ שקולה-CPS לפרוצדורה f אם לכל ערכי קלט x1,x2,…,x3 ולכל continuation המסומן cont, מתקיים:
```typescript
(f$ x1 … xn cont) = (cont (f x1 … xn))
```
טענה: הפרוצדורה fact$ שקולה-CPS לפרוצדורה fact. כלומר, לכל מספר טבעי, n, ולכל continuation, אשר יסומן על ידי c, מתקיים:  
```typescript
(fact$ n c) = (c (fact n))
```
הוכחה: כיוון שהפרוצדורה fact היא רקורסיבית, ההוכחה מתבצעת על ידי שימוש באינדוקציה.

בסיס האינדוקציה: n=0
```typescript
a-e[ (fact$ 0 c) ] ==>* a-e[ (c 1) ] = a-e[ (c (fact 0)) ]
```
(הסימון a-e הוא קיצור עבור applicative-eval)

הנחת האינדוקציה: עבור n=k∈ N הטענה מתקיימת לכל k≥i. כלומר
```typescript
(fact$ i c) = (c (fact i))
```
צעד האינדוקציה: יהא n=k+1,k∈N, אזי:
```typescript
a-e [ (fact$ n c) ] ==>*
a-e [ (fact$ (- n 1) (lambda (res) (c (* n res)))) ] ==>*
```

מהנחת האינדוקציה, נקבל:
```typescript
a-e [ ((lambda (res) (c (* n res))) (fact (- n 1))) ] ==>*
a-e [ (c (* n (fact (- n 1)))) ] =
a-e [ (c (fact n)) ]
```

