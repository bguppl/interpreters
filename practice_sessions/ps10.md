<h1><b>Lazy-Lists and Continuation Passing Style (CPS)</b></h1>

<h2><b>Practical Session - Week #10</b></h2>

## Lists-Lazy

×ª×–×›×•×¨×ª: ×¨×©×™××•×ª ×¢×¦×œ×•×ª ×”×Ÿ ××‘× ×™ × ×ª×•× ×™× ×¡×“×¨×ª×™×™× ×”×××¤×©×¨×™× ×“×—×™×™×” ×©×œ ×—×™×©×•×‘ ×•×©××™×¨×” ×©×œ ××™×‘×¨×™× ××ª×•×›×.
×”×™×ª×¨×•× ×•×ª ×‘×©×™××•×© ×‘×”×Ÿ:
* ××™×Ÿ ×¦×•×¨×š ×œ××—×¡×Ÿ ×‘×–×™×›×¨×•×Ÿ ××ª ×›×œ ××™×‘×¨×™ ×”×¨×©×™××”. ×‘×¢×–×¨×ª ×¨×©×™××•×ª ×¢×¦×œ×•×ª × ×™×ª×Ÿ ×œ×™×™×¦×’ ××£ ×¡×“×¨×•×ª ××™× ×¡×•×¤×™×•×ª.
* ×“×—×™×™×ª ×—×™×©×•×‘ ××™×‘×¨×™× ×‘×¨×©×™××” ×œ×–××Ÿ ×‘×• × ×“×§×§ ×œ×”× â€“ ×™×™×ª×›×Ÿ ×©×œ× × ×–×“×§×§ ×œ×›×œ ××™×‘×¨×™ ×”×¨×©×™××”.

× ×’×“×™×¨ ××ª ×¢×¨×›×™ ×”×˜×™×¤×•×¡ ×©×œ ×¨×©×™××•×ª ×¢×¦×œ×•×ª ×‘××•×¤×Ÿ ×¨×§×•×¨×¡×™×‘×™:

```typescript
LzL = { empty-lzl } âˆª (Scheme-Type Ã— [Empty â†’ LzL])
```
×–×”×• ADT ×¢×‘×•×¨ ×¨×©×™××•×ª ×¢×¦×œ×•×ª (×”××™××•×© ××•×¤×™×¢ ×‘×¡×¤×¨ ×”×§×•×¨×¡):

```typescript
; Signature: cons-lzl(x, f)
; Type: [T * [Empty -> LzL] -> LzL]

; Signature: head(lz-list)
; Type: [LzL -> T]
; Pre-condition: non-empty LzL

; Signature: tail(lz-list)
; Type: [LzL -> LzL]
; Pre-condition: non-empty LzL

; Signature: empty-lzl?(exp)
; Type: [T -> Boolean]

; Signature: nth(lz-list, n)
; Type: [LzL * Number -> T]

; Signature: take(lz-list, n)
; Type: [LzL * Number -> List]
```

#### ×©××œ×” 1 â€“ ×”×©×¢×¨×ª ×§×•×œ×¥
× ×’×“×™×¨ ××ª ×”×¤×•× ×§×¦×™×”:

<p align="center">
<img src="https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/resources/ps10/collatz%20exmple.png" align="center" border="0" alt="\[f(n)=\begin{cases}n/2, & \text{n is even}\\3n+1&\text{n is odd}\end{cases}\]" width="214" height="50" />
</p>

×”×©×¢×¨×ª ×§×•×œ×¥ ×’×•×¨×¡×ª ×›×™ ×œ×›×œ n>1 ××ª×§×™×™× ×›×™ ×”×¡×“×¨×” n,f(n),f(f(n)),f(f(f(n)))â€¦ ×ª××™×“ ××ª×›× ×¡×ª ×‘-1. ×œ××©×œ ×¢×‘×•×¨ n=563: 

563 -> 1690 -> 845 -> 2536 -> 1268 -> 634 -> 317 -> 952 -> 476 -> 238 -> 119 -> 358 -> 179 -> 538 -> 269 -> 808 -> 404 -> 202 -> 101 -> 304 -> 152 -> 76 -> 38 -> 19 -> 58 -> 29 -> 88 -> 44 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

× ×¨×¦×” ×œ×”×’×“×™×¨ ××ª ×”×¨×©×™××” ×”×¢×¦×œ×” ×”××›×™×œ×” ××ª ×¡×“×¨×ª ×§×•×œ×¥ ×¢×‘×•×¨ n ×›×œ×©×”×•.

```typescript
; Signature: lzl-collatz(n)
; Type: [Number -> LzL(Number)]
; Purpose: Generate the (possibly infinite) series { n, f(n), f(f(n)), ... },
; where f(n) is collatz function
; Pre-condition: n is a natural number greater than zero
(define lzl-collatz
    (lambda (n)
        (if (< n 2)
            (cons-lzl n (lambda () empty-lzl))
            (cons-lzl n
                (lambda ()
                    (if (= (modulo n 2) 0)
                        (lzl-collatz (/ n 2))
                        (lzl-collatz (+ (* 3 n) 1))))))))
> (take (lzl-collatz 563) 44)
'(563 1690 845 2536 1268 634 317 952 476 238 119 358 179 538 269 808 404 202
101 304 152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)
```
××” ×”×˜×™×¤×•×¡ ×©×œ lzl-collatz? ×”×× ×”×¤×¨×•×¦×“×•×¨×” ×”×™× well-typed? ×”×× ```(head (lzl-collatz n))``` ×¢×‘×•×¨ n ×˜×‘×¢×™ ×›×œ×©×”×™ ×ª××™×“ ×ª×¦×œ×™×—?


#### ×©××œ×” 2 â€“ ×¡×“×¨×ª ×”×”×¤×¢×œ×•×ª ×”×¢×¦××™×•×ª

×‘×”×™× ×ª×Ÿ ×¤×•× ×§×¦×™×” ![equation 1](https://render.githubusercontent.com/render/math?math=f) ×•×¢×¨×š ![equation 2](https://render.githubusercontent.com/render/math?math=x) , × ×’×“×™×¨ ××ª ×¡×“×¨×ª ×”×”×¨×›×‘×•×ª ×”×¢×¦××™×•×ª ×œ×”×™×•×ª ![equation 3](http://www.sciweavers.org/tex2img.php?eq=%20%5C%7Bx%2Cf(x)%2Cf(f(x))%2Cf(f(f(x)))%2C...%5C%7D&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=) . ×”×¡×“×¨×”
×™×›×•×œ×” ×œ×”×™×•×ª ×¡×•×¤×™×ª, ××• ××™× ×¡×•×¤×™×ª. × ×¨×¦×” ×œ×™×™×¦×¨ ××ª ×”×¨×©×™××” ×”×¢×¦×œ×” ×©××™×‘×¨×™×” ×”× ××™×‘×¨×™ ×”×¡×“×¨×”. ×”×¨×©×™××” ×ª×™×’××¨ ×›××©×¨
×”×’×™×¢×” ×œ× ×§×•×“×ª ×©×‘×ª, ×›×œ×•××¨ ×›××©×¨ ×”×¢×¨×š ×”××•×—×–×¨ ××”×¤×¢×œ×ª ![equation 4](https://render.githubusercontent.com/render/math?math=f) ×”×•× ××•×ª×• ×”×¢×¨×š ×©×¢×œ×™×• ![equation 5](https://render.githubusercontent.com/render/math?math=f) ×”×•×¤×¢×œ×”.

```typescript
; Signature: lzl-apply(f, x)
; Type: [[T -> T] * T -> LzL]
; Purpose: Generate the self-application series of f on x
(define lzl-apply
    (lambda (f x)
        (let ((fx (f x)))
            (if (= fx x)
                (cons-lzl x (lambda () empty-lzl))
                (cons-lzl x (lambda () (lzl-apply f fx)))))))
> (take (lzl-apply (lambda (x) (+ 1 (/ 1 x))) 1.0) 100)
'(1.0 2.0 1.5 1.6666666666666665 1.6 1.625 ... 1.6180339887498951)
                             ğ‘™ğ‘’ğ‘›ğ‘”ğ‘¡â„ = 38

> (take (lzl-apply (lambda (x) x) 1) 100)
'(1)

```
## Continuation Passing Style (CPS) 

×¤×¨×“×™×’××” ×ª×›× ×•×ª×™×ª ×‘×” ×œ×›×œ ×¤×¨×•×¦×“×•×¨×ª ××©×ª××© × ×™×ª×Ÿ ×¤×¨××˜×¨ × ×•×¡×£ ×©×”×™× ×• ×¤×¨×•×¦×“×•×¨×”, ××©×¨ ××”×•×•×” ××ª ×”××©×š ×”×—×™×©×•×‘ ×©×™×© ×œ×‘×¦×¢ ×‘×ª×•× ×¤×¢×•×œ×ª ×¤×¨×•×¦×“×•×¨×ª ×”××©×ª××© (×•×¢×œ ×›×Ÿ × ×§×¨× ×”×¤×¨××˜×¨ continuation). ×—×œ×§ ××Ÿ ×”××•×˜×™×‘×¦×™×” ×œ×©×™××•×© ×‘×¤×¨×“×™×’××ª ×ª×›× ×•×ª ×–×• ×”×™× ×”×©×œ×™×˜×” ×©×”×™× ×××¤×©×¨×ª ×‘×‘×§×¨×” ×©×œ ×”×ª×•×›× ×™×ª:

1.	×‘××”×œ×š ×›×ª×™×‘×ª ×¤×¨×•×¦×“×•×¨×•×ª ××©×ª××© ×‘×©×™×˜×ª CPS, ×›×œ ×§×¨×™××” ×¨×§×•×¨×¡×™×‘×™×ª × ×›×ª×‘×ª ×›×š ×©×”×™× ×‘×¢××“×ª ×–× ×‘. ×œ×›×Ÿ, ××¢×¦× ×”×©×™××•×© ×‘×©×™×˜×”, ×”×¤×¨×•×¦×“×•×¨×” ×ª×™×™×¦×¨ ×ª×”×œ×™×š ××™×˜×¨×˜×™×‘×™.
2. ×©×™×˜×ª	CPS ×××¤×©×¨×ª ×œ×©×œ×•×˜ ×‘×¡×“×¨ ×œ×¤×™×• ×”×ª×•×›× ×™×ª ×ª×—×©×‘ ×‘×™×˜×•×™×™×. ×œ××©×œ, ×× × ×××© ×—×™×¤×•×© ×‘×¢×¥, × ×•×›×œ ×œ×‘×—×•×¨ ×× ×œ×—×¤×© ×§×•×“× ×‘×¢× ×£ ×”×™×× ×™ ××• ×‘×©×××œ×™ (×œ×¢×•××ª ×–××ª, ×œ×œ× CPS × ×”×™×™×” ×ª×œ×•×™×™× ×‘×¡×“×¨ ×”×¢×¨×›×ª ×”×‘×™×˜×•×™×™× ×”××•×‘× ×” ×‘-interpreter).
3.	×”×©×œ×™×˜×” ×‘×‘×§×¨×ª ×”×ª×•×›× ×™×ª ×××¤×©×¨×ª ×œ× ×§×•×˜ ×‘×¤×¢×•×œ×” ×©×•× ×” ×‘××§×¨×” ×©×œ ×”×¦×œ×—×” / ×›×™×©×œ×•×Ÿ ××• ×™×¦×™××” ×™×©×™×¨×” (exception) ×‘××”×œ×š ×¨×§×•×¨×¡×™×” (××• ××™×˜×¨×¦×™×”) ×•×›×Ÿ ×××¤×©×¨×ª ×œ×”×—×–×™×¨ ×›××” ×¢×¨×›×™× ×‘×™×—×“. 


```typescript
; Type: [Number -> Number]
; Purpose: To calculate the factorial of n.
(define fact
    (lambda (n)
        (if (= n 0)
            1
            (* n (fact (- n 1))))))
```
×›×¢×ª, × ×××© ××ª fact ×‘×©×™×˜×ª CPS ×•× ××—×™×© ××ª ××•×¤×Ÿ ×”×¤×¢×•×œ×” ×©×œ×”:
```typescript
; Type: [Number * [Number->T1] -> T1]
; Purpose: Returns the application of the
; continuation c on the factorial of n.
(define fact$
    (lambda (n c)
        (if (= n 0)
            (c 1)
            (fact$ (- n 1)
                (lambda (fact_n-1)
                    (c (* n fact_n-1)))))))
> (fact 5)
120
> (fact$ 5 add1)
121
```
×“×™×•×Ÿ: ××“×•×¢ ×”×ª×•×¦××•×ª ××™× ×Ÿ ×–×”×•×ª? ×›×™×¦×“ × ×¨×¦×” ×œ×§×‘×•×¢ ×‘×“×¨×š ×›×œ×œ ××ª ×¤×¨×•×¦×“×•×¨×ª ×”-continuation ×©× ×¢×‘×™×¨ ×œ×§×¨×™××” ×”×¨××©×•× ×”?

×”×•×›×—×ª × ×›×•× ×•×ª: ×œ××—×¨ ×”××¨×ª ×¤×¨×•×¦×“×•×¨×” ×œ×’×¨×¡×ª ×”-CPS ×©×œ×”, × ×“×¨×©×ª ×”×•×›×—×ª × ×›×•× ×•×ª. ×”× ×›×•× ×•×ª × ×©×¢× ×ª ×¢×œ ×”×¦×’×ª ×©×§×™×œ×•×ª ×‘×™×Ÿ ×©×ª×™ ×”×’×¨×¡××•×ª, ×‘××•×‘×Ÿ ×”×‘×: ×‘×”×¤×¢×œ×ª ×”××œ×’×•×¨×™×ª× applicative-eval ×¢×œ ×§×¨×™××” ××ª××™××” ×œ×›×œ ××—×ª ××Ÿ ×”×’×¨×¡××•×ª, ×”×—×™×©×•×‘ ×™×¡×ª×™×™× ×•×™×•×—×–×¨ ×¢×¨×š ×–×”×”. ×œ×©× ×›×š, × ×–×“×§×§ ×œ×”×’×“×¨×ª ×”×©×§×™×œ×•×ª ×”×‘××”:

×”×’×“×¨×”: ×¤×¨×•×¦×“×•×¨×” f$ ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” f ×× ×œ×›×œ ×¢×¨×›×™ ×§×œ×˜ x1,x2,â€¦,x3 ×•×œ×›×œ continuation ×”××¡×•××Ÿ cont, ××ª×§×™×™×:
```typescript
(f$ x1 â€¦ xn cont) = (cont (f x1 â€¦ xn))
```
×˜×¢× ×”: ×”×¤×¨×•×¦×“×•×¨×” fact$ ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” fact. ×›×œ×•××¨, ×œ×›×œ ××¡×¤×¨ ×˜×‘×¢×™, n, ×•×œ×›×œ continuation, ××©×¨ ×™×¡×•××Ÿ ×¢×œ ×™×“×™ c, ××ª×§×™×™×:  
```typescript
(fact$ n c) = (c (fact n))
```
×”×•×›×—×”: ×›×™×•×•×Ÿ ×©×”×¤×¨×•×¦×“×•×¨×” fact ×”×™× ×¨×§×•×¨×¡×™×‘×™×ª, ×”×”×•×›×—×” ××ª×‘×¦×¢×ª ×¢×œ ×™×“×™ ×©×™××•×© ×‘××™× ×“×•×§×¦×™×”.

×‘×¡×™×¡ ×”××™× ×“×•×§×¦×™×”: n=0
```typescript
a-e[ (fact$ 0 c) ] ==>* a-e[ (c 1) ] = a-e[ (c (fact 0)) ]
```
(×”×¡×™××•×Ÿ a-e ×”×•× ×§×™×¦×•×¨ ×¢×‘×•×¨ applicative-eval)

×”× ×—×ª ×”××™× ×“×•×§×¦×™×”: ×¢×‘×•×¨ n=kâˆˆ N ×”×˜×¢× ×” ××ª×§×™×™××ª ×œ×›×œ kâ‰¥i. ×›×œ×•××¨
```typescript
(fact$ i c) = (c (fact i))
```
×¦×¢×“ ×”××™× ×“×•×§×¦×™×”: ×™×”× n=k+1,kâˆˆN, ××–×™:
```typescript
a-e [ (fact$ n c) ] ==>*
a-e [ (fact$ (- n 1) (lambda (res) (c (* n res)))) ] ==>*
```

××”× ×—×ª ×”××™× ×“×•×§×¦×™×”, × ×§×‘×œ:
```typescript
a-e [ ((lambda (res) (c (* n res))) (fact (- n 1))) ] ==>*
a-e [ (c (* n (fact (- n 1)))) ] =
a-e [ (c (fact n)) ]
```

