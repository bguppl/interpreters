<span dir="rtl">*עקרונות שפות תכנות, סמסטר ב'* – 2016</span>

*<span dir="rtl">תרגול</span> 6 <span dir="rtl">:</span> Lazy-Lists,
Continuation Passing Style (CPS)* <span dir="rtl"></span>

**<u><span dir="rtl">חלק א' –</span> Lazy-Lists</u>**

<span dir="rtl">תזכורת: רשימות עצלות הן מבני נתונים סדרתיים המאפשרים
דחייה של חישוב ושמירה של איברים מתוכם.</span>

<span dir="rtl">היתרונות בשימוש בהן</span>:

-   <span dir="rtl">אין צורך לאחסן בזיכרון את כל איברי הרשימה. בעזרת
    רשימות עצלות ניתן לייצג אף סדרות אינסופיות.</span>

-   <span dir="rtl">דחיית חישוב איברים ברשימה לזמן בו נדקק להם – ייתכן
    שלא נזדקק לכל איברי הרשימה.</span>

<span dir="rtl">נגדיר את ערכי הטיפוס של רשימות עצלות באופן
רקורסיבי:</span>

LzL = { empty-lzl } ∪ (Scheme-Type × \[Empty → LzL\])

ADT <span dir="rtl">עבור רשימות עצלות (המימוש מופיע בספר הקורס):</span>

## 

<span dir="rtl">  
</span>

## <span dir="rtl">שאלה 1 – השערת קולץ</span>

<span dir="rtl">נגדיר את הפונקציה:</span>

$$f(n) = \\left\\{ \\begin{matrix}
n/2, & \\text{n\\ }\\text{is\\ even} \\\\
3n + 1, & \\text{n\\ }\\text{is\\ odd} \\\\
\\end{matrix} \\right.\\ $$

<span dir="rtl">השערת קולץ גורסת כי לכל</span> *n* &gt; 1 <span
dir="rtl">מתקיים כי הסדרה</span>
*n*, *f*(*n*), *f*(*f*(*n*)), *f*(*f*(*f*(*n*)))… <span dir="rtl">תמיד
מתכנסת ב-1. למשל עבור</span> n=563<span dir="rtl">:</span>

563 -&gt; 1690 -&gt; 845 -&gt; 2536 -&gt; 1268 -&gt; 634 -&gt; 317 -&gt;
952 -&gt; 476 -&gt; 238 -&gt; 119 -&gt; 358 -&gt; 179 -&gt; 538 -&gt;
269 -&gt; 808 -&gt; 404 -&gt; 202 -&gt; 101 -&gt; 304 -&gt; 152 -&gt; 76
-&gt; 38 -&gt; 19 -&gt; 58 -&gt; 29 -&gt; 88 -&gt; 44 -&gt; 22 -&gt; 11
-&gt; 34 -&gt; 17 -&gt; 52 -&gt; 26 -&gt; 13 -&gt; 40 -&gt; 20 -&gt; 10
-&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1

<span dir="rtl">נרצה להגדיר את הרשימה העצלה המכילה את סדרת קולץ
עבור</span> n <span dir="rtl">כלשהו.</span>

<span dir="rtl">מה הטיפוס של</span> lzl-collatz<span dir="rtl">? האם
הפרוצדורה היא</span> well-typed<span dir="rtl">? האם</span> (head
(lzl-collatz n)) <span dir="rtl">עבור</span> n <span dir="rtl">טבעי
כלשהי **תמיד** תצליח?</span>

## <span dir="rtl">שאלה 2 – סדרת ההפעלות העצמיות</span>

<span dir="rtl">בהינתן פונקציה</span> *f* <span dir="rtl">וערך</span>
*x*<span dir="rtl">, נגדיר את סדרת ההרכבות העצמיות להיות</span>
{*x*,*f*(*x*),*f*(*f*(*x*)), *f*(*f*(*f*(*x*))),…}<span dir="rtl">.
הסדרה יכולה להיות סופית, או אינסופית. נרצה לייצר את הרשימה העצלה שאיבריה
הם איברי הסדרה. הרשימה תיגמר כאשר הגיעה לנקודת שבת, כלומר כאשר הערך
המוחזר מהפעלת</span> *f* <span dir="rtl">הוא אותו הערך שעליו</span> *f*
<span dir="rtl">הופעלה.</span>

**<u><span dir="rtl">חלק ב' –</span> Continuation Passing Style
(CPS)</u>**

Continuation Passing Style<span dir="rtl">: פרדיגמה תכנותית בה לכל
פרוצדורת משתמש ניתן פרמטר נוסף שהינו פרוצדורה, אשר מהווה את המשך החישוב
שיש לבצע בתום פעולת פרוצדורת המשתמש (ועל כן נקרא הפרמטר</span>
continuation<span dir="rtl">). חלק מן המוטיבציה לשימוש בפרדיגמת תכנות זו
היא השליטה שהיא מאפשרת בבקרה של התוכנית:</span>

1.  <span dir="rtl">במהלך כתיבת פרוצדורות משתמש בשיטת</span> CPS<span
    dir="rtl">, כל קריאה רקורסיבית נכתבת כך שהיא בעמדת זנב. לכן, מעצם
    השימוש בשיטה, הפרוצדורה תייצר תהליך איטרטיבי.</span>

2.  CPS <span dir="rtl">מאפשר לשלוט בסדר לפיו התוכנית תחשב ביטויים.
    למשל, אם נממש חיפוש בעץ, נוכל לבחור אם לחפש קודם בענף הימני או
    בשמאלי (לעומת זאת, ללא</span> CPS <span dir="rtl">נהייה תלויים בסדר
    הערכת הביטויים המובנה ב-</span>interpreter<span dir="rtl">).</span>

3.  <span dir="rtl">השליטה בבקרת התוכנית מאפשרת לנקוט בפעולה שונה במקרה
    של הצלחה / כישלון או יציאה ישירה (</span>exception<span dir="rtl">)
    במהלך רקורסיה (או איטרציה) וכן מאפשרת להחזיר כמה ערכים ביחד.</span>

## <span dir="rtl">שאלה 1 – אופן פעולת פרוצדורה בגרסת</span> CPS <span dir="rtl">והוכחת נכונות</span>

<span dir="rtl">ניזכר במימוש של הפרוצדורה</span> fact <span
dir="rtl">ללא שימוש ב-</span>CPS<span dir="rtl">:</span>

<span dir="rtl">כעת, נממש את</span> fact <span dir="rtl">בשיטת</span>
CPS <span dir="rtl">ונמחיש את אופן הפעולה שלה:</span>

<span dir="rtl">**דיון**: מדוע התוצאות אינן זהות? כיצד נרצה לקבוע בדרך
כלל את פרוצדורת ה-</span>continuation <span dir="rtl">שנעביר לקריאה
הראשונה?</span>

<span dir="rtl">  
</span>

<span dir="rtl">**הוכחת נכונות:** לאחר המרת פרוצדורה לגרסת ה-</span>CPS
<span dir="rtl">שלה, נדרשת הוכחת נכונות. הנכונות נשענת על הצגת שקילות
בין שתי הגרסאות, במובן הבא: בהפעלת האלגוריתם</span> applicative-eval
<span dir="rtl">על קריאה מתאימה לכל אחת מן הגרסאות, החישוב יסתיים ויוחזר
ערך זהה. לשם כך, נזדקק להגדרת השקילות הבאה:</span>

<span dir="rtl">**  
הגדרה**: פרוצדורה</span> f$ <span dir="rtl">שקולה-</span>CPS <span
dir="rtl">לפרוצדורה</span> f <span dir="rtl">אם לכל ערכי קלט</span>
x1,x2,…,x3 <span dir="rtl">ולכל</span> continuation <span
dir="rtl">המסומן</span> cont<span dir="rtl">, מתקיים:</span>

<span dir="rtl">**טענה**: הפרוצדורה</span> fact$ <span
dir="rtl">שקולה-</span>CPS <span dir="rtl">לפרוצדורה</span> fact<span
dir="rtl">. כלומר, לכל מספר טבעי,</span> n<span dir="rtl">, ולכל</span>
continuation<span dir="rtl">, אשר יסומן על ידי</span> c<span dir="rtl">,
מתקיים:</span>

<span dir="rtl">  
**הוכחה:** כיוון שהפרוצדורה</span> fact <span dir="rtl">היא רקורסיבית,
ההוכחה מתבצעת על ידי שימוש באינדוקציה.</span>

<span dir="rtl">  
**בסיס האינדוקציה**:</span> *n* = 0

<span dir="rtl">**הנחת האינדוקציה**: עבור</span> *n* = *k*∈ ℕ <span
dir="rtl">הטענה מתקיימת לכל</span> *k* ≥ *i*<span dir="rtl">.
כלומר</span>

<span dir="rtl">**צעד האינדוקציה**: יהא</span>
*n* = *k* + 1, *k* ∈ ℕ<span dir="rtl">, אזי:</span>

<span dir="rtl">מהנחת האינדוקציה, נקבל:</span>

**<span dir="rtl">כללי אצבע להמרת פרוצדורה <span
class="smallcaps">רקורסיבית לפרוצדורה שקולה-</span></span><span
class="smallcaps">CPS<span dir="rtl">:</span></span>**

> <span dir="rtl">בהינתן פרוצדורה רקורסיבית,</span> f<span dir="rtl">,
> עם הפרמטרים הפורמאליים</span> x1,…,xn<span dir="rtl">, פרוצדורה
> שקולה-</span>CPS <span dir="rtl">לה תסומן</span> f$ <span
> dir="rtl">ותופעל על ארגומנט נוסף,</span> c<span dir="rtl">,
> ה-</span>continuation<span dir="rtl">. העקרונות שינחו אותנו
> בכתיבת</span> f$ <span dir="rtl">הם כדלקמן:</span>

1.  <span dir="rtl">נפעיל את</span> c <span dir="rtl">על ערכים מוחזרים
    (כחלק ממקרה הבסיס, או בתוך</span> continuation <span dir="rtl">הנוצר
    במהלך הריצה).</span>

2.  <span dir="rtl">נקפיד לכתוב כל קריאה לפרוצדורת משתמש בתוך</span> f$
    <span dir="rtl">כך שהקריאה תהיה בעמדת זנב.</span>

3.  <span dir="rtl">כתיבת ה-</span>continuation<span dir="rtl">:</span>

    1.  <span dir="rtl">כשנבצע בתוך</span> f$ <span dir="rtl">קריאה
        רקורסיבית כלשהי עם ארגומנטים</span> x1,…,xn<span dir="rtl">,
        נתבסס על <u>הנחת האינדוקציה</u> (המקטינה את הבעיה). כלומר, נניח
        כי התשובה עבור הבעיה המוקטנת מתקבלת כארגומנט של  
        ה-</span>continuation<span dir="rtl">.</span>

    2.  <span dir="rtl">בכתיבת ה-</span>continuation<span dir="rtl">,
        נקיים את <u>צעד האינדוקציה</u> ונפעל על הפתרון עבור הבעיה
        המוקטנת כדי לקבל את הפתרון לבעיה הגדולה יותר.</span>

4.  <span dir="rtl">בכתיבת פרוצדורה בשיטת</span> CPS<span dir="rtl">,
    נקפיד שכל פרוצדורת משתמש (לא פרימיטיבית) המשמשת את</span> f$ <span
    dir="rtl">תהיה גם היא כתובה בשיטת</span> CPS<span dir="rtl">.</span>

5.  <span dir="rtl">בדרך כלל, לא נרצה לבצע מניפולציה על הערך המוחזר של
    הפונקציה ולכן נשתמש בפונקציית הזהות</span> id<span dir="rtl">  
    כ-</span>continuation <span dir="rtl">ההתחלתי.</span>

**<span dir="rtl">שאלה 2</span> – <span dir="rtl">פונקציות</span> CPS
<span dir="rtl">מסדר גבוה</span>**

<span dir="rtl">  
נמיר את הפונקציה</span> foldr <span dir="rtl">ל-</span>CPS<span
dir="rtl">.</span> <span dir="rtl">תזכורת:</span>

<span dir="rtl"></span>

<span dir="rtl">**נשים לב**: מדוע לא יכולנו להפעיל את</span> c <span
dir="rtl">על תוצאת</span> op$ <span dir="rtl">במקום להעביר לה את</span>
c <span dir="rtl">כארגומנט? ראשית, לו עשינו כך, הקריאה לא הייתה בעמדת
זנב. בנוסף, הבעיה המהותית יותר היא שבמקרה כזה היינו מאבדים את השליטה על
תהליך החישוב המגולמת בתוך ה-</span>continuation<span dir="rtl">.</span>

**  
**

**<span dir="rtl">שאלה 3</span> – <span dir="rtl">שימוש במספר</span>
continuations**

<span dir="rtl">לצורך הפשטת העבודה מול רשימות, נשתמש ב-</span>ADT <span
dir="rtl">עבור עצים (המימוש מופיע בספר הקורס). כפי שכבר ראינו בעבר עבור
רשימות ורשימות עצלות, גם עץ מוגדר בצורה רקורסיבית:</span>

1.  Empty-Tree <span dir="rtl">הוא עץ</span>

2.  <span dir="rtl">אם</span> t <span dir="rtl">עץ, אזי לכל</span>
    e<span dir="rtl">: הערך של</span> (add-subtree (make-leaf e) t)
    <span dir="rtl">הוא עץ</span>

<span dir="rtl">ממשק ה-</span>ADT<span dir="rtl">:</span>

<span dir="rtl">  
</span>

<span dir="rtl">הפונקציה</span> replace-leaves$ <span dir="rtl">מקבלת עץ
הומוגני, פרדיקט (שאינו כתוב בגרסת</span> CPS<span dir="rtl">),
ביטוי</span> new <span dir="rtl">מטיפוס עלי העץ ושני</span>
continuations<span dir="rtl">: אחד עבור הצלחה והשני עבור כישלון. המטרה
היא להחליף את כל העלים אשר מקיימים את הפרדיקט, בביטוי</span> new<span
dir="rtl">. נשים לב שניתן להכליל את הקוד ע"י העברת פרוצדורה בתור</span>
new <span dir="rtl">ולשנות את העלה בצורה דינמית.</span>

<span dir="rtl">**הערה:** יכולנו במקום</span> succ <span
dir="rtl">ו-</span>fail <span dir="rtl">להעביר פרוצדורות שמבצעות
מניפולציות אחרות על התוצאה – כל זאת מבלי לשנות שורה אחת בקוד הקיים
של</span> replace-leaves$<span dir="rtl">. לדוגמה:</span>

**<span dir="rtl">שאלה 4</span> – <span dir="rtl"></span>continuation
<span dir="rtl">עם מספר ארגומנטים</span>**

<span dir="rtl">פרוצדורות ה-</span>CPS <span dir="rtl"> שאנו יוצרים,
למעשה אינן בעצמן מחשבות את התוצאה, אלא מייצרות (על ידי יצירת</span>
continuations<span dir="rtl">) פרוצדורה המהווה את תהליך החישוב. אם נקפיד
לייצר</span> continuations <span dir="rtl">אשר מקבלים מספר ארגומנטים
ובאופן עקבי נפעיל אותם על אותו מספר של ארגומנטים, נוכל לומר שתהליך
החישוב שנייצר "מחזיר" מספר ערכים.</span>

<span dir="rtl">נראה להלן פרוצדורה בה תכונה זו שימושית. הפרוצדורה מפצלת
רשימה נתונה לשתי רשימות לפי פרדיקט פרימיטיבי,</span> pred<span
dir="rtl">. ה-</span>continuation <span dir="rtl">מקבל שני ארגומנטים:
רשימת האיברים מן הבעיה המוקטנת אשר קיימו את הפרדיקט ורשימת אלו שלא. על
שתי הרשימות יתבצע המשך החישוב.</span>

**<span dir="rtl">  
</span>**

**<span dir="rtl">דוגמאות נוספות לעיון</span>**

# <span dir="rtl">שאלה 1 – "7 בום"</span>

<span dir="rtl">נייצר את הרשימה העצלה שאיבריה מתאימים לחוקי המשחק 7
בום</span>:

**<span dir="rtl">שאלה 2</span> – <span dir="rtl">רקורסיה הדדית
עם</span> CPS**

<span dir="rtl">  
</span>

<span dir="rtl">כאשר נרצה להמיר פונקציות רקורסיביות הדדיות
ל-</span>CPS<span dir="rtl">, נמיר את כולן ל-</span>CPS<span
dir="rtl">.</span>

<span dir="rtl">**נשים לב:** על שתי הפונקציות להיות כתובות בצורת</span>
CPS<span dir="rtl">. אם היינו משתמשים ב-</span> even?$<span
dir="rtl">יחד עם</span> odd <span dir="rtl">שאינה כתובה כ-</span>CPS
<span dir="rtl">(ובהנחה ש-</span>odd <span dir="rtl">שוב קוראת
ל-</span>even?$<span dir="rtl">), היינו "זורקים" את
ה-</span>continuation <span dir="rtl">שהצטבר בכל פעם שהיינו קוראים
ל-</span>even?$ <span dir="rtl">מתוך</span> odd <span dir="rtl">(כיוון
ש-</span>odd <span dir="rtl">אינה כתובה בצורת</span> CPS<span
dir="rtl">, היא אינה מקבלת</span> continuation <span dir="rtl">כארגומנט
ולכן גם לא מעבירה</span> continuation<span dir="rtl">).</span>

**<span dir="rtl">שאלה 3</span> – <span dir="rtl">גרסת</span> CPS <span
dir="rtl">עבור פרוצדורה למציאת מחלק משותף מקסימאלי (</span>gcd<span
dir="rtl">)</span>**

> <span dir="rtl">  
> נתחיל בבחינת הפרוצדורה בה תהליך החישוב הוא איטרטיבי:</span>

<span dir="rtl">  
</span>

> <span dir="rtl">כתיבת גרסת ה-</span>CPS <span dir="rtl">היא מידית:
> ה-</span>continuation <span dir="rtl">יוכל להישאר</span> id <span
> dir="rtl">(כלומר ללא שינוי) לאורך כל החישוב. זאת, כיוון ש-</span>n
> <span dir="rtl">משמש כ-"צובר" לתשובה במקרה זה. נבחין כי למעשה איננו
> מרחיבים את הפונקציה "הנשלחת" כ -</span> continuation <span
> dir="rtl">במהלך ריצת</span> gcd<span dir="rtl">$:</span>

**<span dir="rtl">שאלה 4</span> – <span dir="rtl">גרסת</span>CPS <span
dir="rtl">עבור פרוצדורה לחישוב אורך רשימה  
</span>**

> <span dir="rtl">נבחן תחילה את המימוש של</span> length<span dir="rtl">,
> המחשבת את אורכה של רשימה:</span>
>
> <span dir="rtl">ובגרסת</span> CPS<span dir="rtl">:</span>
>
> <span dir="rtl">הרעיון הוא להניח כי אל המשתנה</span> cdr-length <span
> dir="rtl">"יוכנס" האורך של זנב הרשימה (זאת כיוון שקראנו רקורסיבית
> לפונקציה</span> length$ <span dir="rtl">עם (</span>cdr lst<span
> dir="rtl">)). כלומר אנו מניחים כי</span> cdr-length <span
> dir="rtl">חושב וכל שנותר הוא להפעיל את ה-</span>continuation <span
> dir="rtl">על התוצאה שהיא אורך הרשימה כולה (אורך זנב הרשימה + 1). נבחין
> כי בכל שלב באיטרציה נוצרת פונקציית</span> continuation <span
> dir="rtl">חדשה (מורחבת) פרט לשלב האחרון (מקרה הבסיס).</span>
>
> <span dir="rtl">נשים לב: השימוש ב-</span>CPS <span dir="rtl">אינו חוסך
> באופן כללי את הזיכרון הנדרש, אלא רק חוסך את השימוש במקום על המחסנית.
> למעשה, העברנו את השימוש בזיכרון בכל איטרציה מן המחסנית אל
> ה-</span>heap <span dir="rtl">(ה-</span>continuations <span
> dir="rtl">הם</span> closures <span dir="rtl">והם מיוצרים על
> ה-</span>heap<span dir="rtl">).</span>

**<span dir="rtl">שאלה</span> 5 <span dir="rtl"></span>– <span
dir="rtl">גרסת</span> CPS <span dir="rtl">עבור פרוצדורות מסדר גבוה
(</span>map$$<span dir="rtl">)</span>**

<span dir="rtl">אם אנו מניחים כי פרוצדורות המיפוי</span> f <span
dir="rtl">המתקבלת כארגומנט היא פרימיטיבית (ואינה כתובה בצורת</span>
CPS<span dir="rtl">):</span>

> <span dir="rtl">כיוון שהפרוצדורה</span> f <span dir="rtl">אינה כתובה
> בגרסת</span> CPS<span dir="rtl">, הפעלנו את</span> c <span
> dir="rtl">על</span> (cons (f (car lst)) mapped-cdr)<span dir="rtl">.
> כעת, נניח כי</span> f <span dir="rtl">אינה פרימיטיבית, ולכן הומרה
> לגרסת ה</span> CPS <span dir="rtl">שלה,</span> f$<span dir="rtl">.
> נראה כיצד לכתוב את גרסת ה-</span>CPS <span dir="rtl">של</span>
> map<span dir="rtl">, כאשר הפרוצדורה אותה מפעילים על כל אחד מאיברי
> הרשימה,</span> f$<span dir="rtl">, נתונה בעצמה בגרסת</span> CPS<span
> dir="rtl">:</span>

<span dir="rtl">  
</span>

> <span dir="rtl">נתבונן ב-</span>continuation <span dir="rtl">שנבנה
> לאורך החישוב:</span>

map$$ <span dir="rtl">מפעילה את</span> f$ <span dir="rtl">על אברי הרשימה
מהסוף להתחלה (בדוגמה</span> 5 → 4 → 3 → 2 → 1<span dir="rtl">).
הפעלת</span> f <span dir="rtl">והקריאה ל-</span>map <span dir="rtl">אינן
תלויות (אינן מקוננות זו בזו) ולכן ניתן לבחור מה יתרחש קודם בגרסת
ה</span> CPS<span dir="rtl">. כך נקבע את הסדר בו תופעל</span> f$ <span
dir="rtl">על אברי הרשימה (מההתחלה לסוף או להיפך). הגרסה הבאה מפעילה
את</span> f$ <span dir="rtl">על אברי הרשימה לפי הסדר הרגיל של מההתחלה
לסוף:</span>

<span dir="rtl">  
</span>

**<span dir="rtl">שאלה</span> 6 <span dir="rtl">– עצירת החישוב</span>**

<span dir="rtl">הפונקציה</span> mul-list$ <span dir="rtl">מקבלת רשימה של
רשימות ומחזירה מכפלה של כל המספרים ברשימה. אם יש מופע אטומי שאינו מספר
אז יש לעצור את החישוב.</span>
