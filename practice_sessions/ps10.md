[*עקרונות שפות תכנות, סמסטר ב\'* -- 2016]{dir="rtl"}

*[תרגול]{dir="rtl"} 6 [:]{dir="rtl"} Lazy-Lists, Continuation Passing
Style (CPS)* []{dir="rtl"}

**[[חלק א\' --]{dir="rtl"} Lazy-Lists]{.ul}**

[תזכורת: רשימות עצלות הן מבני נתונים סדרתיים המאפשרים דחייה של חישוב
ושמירה של איברים מתוכם.]{dir="rtl"}

[היתרונות בשימוש בהן]{dir="rtl"}:

-   [אין צורך לאחסן בזיכרון את כל איברי הרשימה. בעזרת רשימות עצלות ניתן
    לייצג אף סדרות אינסופיות.]{dir="rtl"}

-   [דחיית חישוב איברים ברשימה לזמן בו נדקק להם -- ייתכן שלא נזדקק לכל
    איברי הרשימה.]{dir="rtl"}

[נגדיר את ערכי הטיפוס של רשימות עצלות באופן רקורסיבי:]{dir="rtl"}

$$\text{LzL}\text{\ =\ }\left\{ \text{\ empty-}\text{lzl}\text{\ } \right\} \cup \left( \text{Scheme-Type\ ×\ }\left\lbrack \text{Empty\ →\ }\text{LzL} \right\rbrack \right)$$

ADT [עבור רשימות עצלות (המימוש מופיע בספר הקורס):]{dir="rtl"}

## 

[\
]{dir="rtl"}

## [שאלה 1 -- השערת קולץ]{dir="rtl"}

[נגדיר את הפונקציה:]{dir="rtl"}

$$f(n) = \left\{ \begin{matrix}
n/2, & \text{n\ }\text{is\ even} \\
3n + 1, & \text{n\ }\text{is\ odd} \\
\end{matrix} \right.\ $$

[השערת קולץ גורסת כי לכל]{dir="rtl"} $n > 1$ [מתקיים כי
הסדרה]{dir="rtl"}
$n,\ f(n),\ f\left( f(n) \right),\ f(f\left( f(n) \right))\ldots$ [תמיד
מתכנסת ב-1. למשל עבור]{dir="rtl"} n=563[:]{dir="rtl"}

563 -\> 1690 -\> 845 -\> 2536 -\> 1268 -\> 634 -\> 317 -\> 952 -\> 476
-\> 238 -\> 119 -\> 358 -\> 179 -\> 538 -\> 269 -\> 808 -\> 404 -\> 202
-\> 101 -\> 304 -\> 152 -\> 76 -\> 38 -\> 19 -\> 58 -\> 29 -\> 88 -\> 44
-\> 22 -\> 11 -\> 34 -\> 17 -\> 52 -\> 26 -\> 13 -\> 40 -\> 20 -\> 10
-\> 5 -\> 16 -\> 8 -\> 4 -\> 2 -\> 1

[נרצה להגדיר את הרשימה העצלה המכילה את סדרת קולץ עבור]{dir="rtl"} n
[כלשהו.]{dir="rtl"}

[מה הטיפוס של]{dir="rtl"} lzl-collatz[? האם הפרוצדורה היא]{dir="rtl"}
well-typed[? האם]{dir="rtl"} (head (lzl-collatz n)) [עבור]{dir="rtl"} n
[טבעי כלשהי **תמיד** תצליח?]{dir="rtl"}

## [שאלה 2 -- סדרת ההפעלות העצמיות]{dir="rtl"}

[בהינתן פונקציה]{dir="rtl"} $f$ [וערך]{dir="rtl"} $x$[, נגדיר את סדרת
ההרכבות העצמיות להיות]{dir="rtl"}
$\left\{ x,f(x),f\left( f(x) \right),\ f\left( f\left( f(x) \right) \right),\ldots \right\}$[.
הסדרה יכולה להיות סופית, או אינסופית. נרצה לייצר את הרשימה העצלה שאיבריה
הם איברי הסדרה. הרשימה תיגמר כאשר הגיעה לנקודת שבת, כלומר כאשר הערך
המוחזר מהפעלת]{dir="rtl"} $f$ [הוא אותו הערך שעליו]{dir="rtl"} $f$
[הופעלה.]{dir="rtl"}

**[[חלק ב\' --]{dir="rtl"} Continuation Passing Style (CPS)]{.ul}**

Continuation Passing Style[: פרדיגמה תכנותית בה לכל פרוצדורת משתמש ניתן
פרמטר נוסף שהינו פרוצדורה, אשר מהווה את המשך החישוב שיש לבצע בתום פעולת
פרוצדורת המשתמש (ועל כן נקרא הפרמטר]{dir="rtl"} continuation[). חלק מן
המוטיבציה לשימוש בפרדיגמת תכנות זו היא השליטה שהיא מאפשרת בבקרה של
התוכנית:]{dir="rtl"}

1.  [במהלך כתיבת פרוצדורות משתמש בשיטת]{dir="rtl"} CPS[, כל קריאה
    רקורסיבית נכתבת כך שהיא בעמדת זנב. לכן, מעצם השימוש בשיטה, הפרוצדורה
    תייצר תהליך איטרטיבי.]{dir="rtl"}

2.  CPS [מאפשר לשלוט בסדר לפיו התוכנית תחשב ביטויים. למשל, אם נממש חיפוש
    בעץ, נוכל לבחור אם לחפש קודם בענף הימני או בשמאלי (לעומת זאת,
    ללא]{dir="rtl"} CPS [נהייה תלויים בסדר הערכת הביטויים המובנה
    ב-]{dir="rtl"}interpreter[).]{dir="rtl"}

3.  [השליטה בבקרת התוכנית מאפשרת לנקוט בפעולה שונה במקרה של הצלחה /
    כישלון או יציאה ישירה (]{dir="rtl"}exception[) במהלך רקורסיה (או
    איטרציה) וכן מאפשרת להחזיר כמה ערכים ביחד.]{dir="rtl"}

## [שאלה 1 -- אופן פעולת פרוצדורה בגרסת]{dir="rtl"} CPS [והוכחת נכונות]{dir="rtl"}

[ניזכר במימוש של הפרוצדורה]{dir="rtl"} fact [ללא שימוש
ב-]{dir="rtl"}CPS[:]{dir="rtl"}

[כעת, נממש את]{dir="rtl"} fact [בשיטת]{dir="rtl"} CPS [ונמחיש את אופן
הפעולה שלה:]{dir="rtl"}

[**דיון**: מדוע התוצאות אינן זהות? כיצד נרצה לקבוע בדרך כלל את פרוצדורת
ה-]{dir="rtl"}continuation [שנעביר לקריאה הראשונה?]{dir="rtl"}

[\
]{dir="rtl"}

[**הוכחת נכונות:** לאחר המרת פרוצדורה לגרסת ה-]{dir="rtl"}CPS [שלה,
נדרשת הוכחת נכונות. הנכונות נשענת על הצגת שקילות בין שתי הגרסאות, במובן
הבא: בהפעלת האלגוריתם]{dir="rtl"} applicative-eval [על קריאה מתאימה לכל
אחת מן הגרסאות, החישוב יסתיים ויוחזר ערך זהה. לשם כך, נזדקק להגדרת
השקילות הבאה:]{dir="rtl"}

[**\
הגדרה**: פרוצדורה]{dir="rtl"} f\$ [שקולה-]{dir="rtl"}CPS
[לפרוצדורה]{dir="rtl"} f [אם לכל ערכי קלט]{dir="rtl"} x1,x2,...,x3
[ולכל]{dir="rtl"} continuation [המסומן]{dir="rtl"} cont[,
מתקיים:]{dir="rtl"}

[**טענה**: הפרוצדורה]{dir="rtl"} fact\$ [שקולה-]{dir="rtl"}CPS
[לפרוצדורה]{dir="rtl"} fact[. כלומר, לכל מספר טבעי,]{dir="rtl"} n[,
ולכל]{dir="rtl"} continuation[, אשר יסומן על ידי]{dir="rtl"} c[,
מתקיים:]{dir="rtl"}

[\
**הוכחה:** כיוון שהפרוצדורה]{dir="rtl"} fact [היא רקורסיבית, ההוכחה
מתבצעת על ידי שימוש באינדוקציה.]{dir="rtl"}

[\
**בסיס האינדוקציה**:]{dir="rtl"} $n = 0$

[**הנחת האינדוקציה**: עבור]{dir="rtl"} $n = k\mathbb{\in \ N}$ [הטענה
מתקיימת לכל]{dir="rtl"} $k \geq i$[. כלומר]{dir="rtl"}

[**צעד האינדוקציה**: יהא]{dir="rtl"} $n = k + 1,\ k\mathbb{\in N}$[,
אזי:]{dir="rtl"}

[מהנחת האינדוקציה, נקבל:]{dir="rtl"}

**[כללי אצבע להמרת פרוצדורה [רקורסיבית לפרוצדורה
שקולה-]{.smallcaps}]{dir="rtl"}[CPS[:]{dir="rtl"}]{.smallcaps}**

> [בהינתן פרוצדורה רקורסיבית,]{dir="rtl"} f[, עם הפרמטרים
> הפורמאליים]{dir="rtl"} x1,...,xn[, פרוצדורה שקולה-]{dir="rtl"}CPS [לה
> תסומן]{dir="rtl"} f\$ [ותופעל על ארגומנט נוסף,]{dir="rtl"} c[,
> ה-]{dir="rtl"}continuation[. העקרונות שינחו אותנו בכתיבת]{dir="rtl"}
> f\$ [הם כדלקמן:]{dir="rtl"}

1.  [נפעיל את]{dir="rtl"} c [על ערכים מוחזרים (כחלק ממקרה הבסיס, או
    בתוך]{dir="rtl"} continuation [הנוצר במהלך הריצה).]{dir="rtl"}

2.  [נקפיד לכתוב כל קריאה לפרוצדורת משתמש בתוך]{dir="rtl"} f\$ [כך
    שהקריאה תהיה בעמדת זנב.]{dir="rtl"}

3.  [כתיבת ה-]{dir="rtl"}continuation[:]{dir="rtl"}

    a.  [כשנבצע בתוך]{dir="rtl"} f\$ [קריאה רקורסיבית כלשהי עם
        ארגומנטים]{dir="rtl"} x1,...,xn[, נתבסס על [הנחת
        האינדוקציה]{.ul} (המקטינה את הבעיה). כלומר, נניח כי התשובה עבור
        הבעיה המוקטנת מתקבלת כארגומנט של\
        ה-]{dir="rtl"}continuation[.]{dir="rtl"}

    b.  [בכתיבת ה-]{dir="rtl"}continuation[, נקיים את [צעד
        האינדוקציה]{.ul} ונפעל על הפתרון עבור הבעיה המוקטנת כדי לקבל את
        הפתרון לבעיה הגדולה יותר.]{dir="rtl"}

4.  [בכתיבת פרוצדורה בשיטת]{dir="rtl"} CPS[, נקפיד שכל פרוצדורת משתמש
    (לא פרימיטיבית) המשמשת את]{dir="rtl"} f\$ [תהיה גם היא כתובה
    בשיטת]{dir="rtl"} CPS[.]{dir="rtl"}

5.  [בדרך כלל, לא נרצה לבצע מניפולציה על הערך המוחזר של הפונקציה ולכן
    נשתמש בפונקציית הזהות]{dir="rtl"} id[\
    כ-]{dir="rtl"}continuation [ההתחלתי.]{dir="rtl"}

**[שאלה 2]{dir="rtl"} -- [פונקציות]{dir="rtl"} CPS [מסדר
גבוה]{dir="rtl"}**

[\
נמיר את הפונקציה]{dir="rtl"} foldr [ל-]{dir="rtl"}CPS[.]{dir="rtl"}
[תזכורת:]{dir="rtl"}

[]{dir="rtl"}

[**נשים לב**: מדוע לא יכולנו להפעיל את]{dir="rtl"} c [על
תוצאת]{dir="rtl"} op\$ [במקום להעביר לה את]{dir="rtl"} c [כארגומנט?
ראשית, לו עשינו כך, הקריאה לא הייתה בעמדת זנב. בנוסף, הבעיה המהותית יותר
היא שבמקרה כזה היינו מאבדים את השליטה על תהליך החישוב המגולמת בתוך
ה-]{dir="rtl"}continuation[.]{dir="rtl"}

**\
**

**[שאלה 3]{dir="rtl"} -- [שימוש במספר]{dir="rtl"} continuations**

[לצורך הפשטת העבודה מול רשימות, נשתמש ב-]{dir="rtl"}ADT [עבור עצים
(המימוש מופיע בספר הקורס). כפי שכבר ראינו בעבר עבור רשימות ורשימות
עצלות, גם עץ מוגדר בצורה רקורסיבית:]{dir="rtl"}

1.  Empty-Tree [הוא עץ]{dir="rtl"}

2.  [אם]{dir="rtl"} t [עץ, אזי לכל]{dir="rtl"} e[: הערך של]{dir="rtl"}
    (add-subtree (make-leaf e) t) [הוא עץ]{dir="rtl"}

[ממשק ה-]{dir="rtl"}ADT[:]{dir="rtl"}

[\
]{dir="rtl"}

[הפונקציה]{dir="rtl"} replace-leaves\$ [מקבלת עץ הומוגני, פרדיקט (שאינו
כתוב בגרסת]{dir="rtl"} CPS[), ביטוי]{dir="rtl"} new [מטיפוס עלי העץ
ושני]{dir="rtl"} continuations[: אחד עבור הצלחה והשני עבור כישלון. המטרה
היא להחליף את כל העלים אשר מקיימים את הפרדיקט, בביטוי]{dir="rtl"} new[.
נשים לב שניתן להכליל את הקוד ע\"י העברת פרוצדורה בתור]{dir="rtl"} new
[ולשנות את העלה בצורה דינמית.]{dir="rtl"}

[**הערה:** יכולנו במקום]{dir="rtl"} succ [ו-]{dir="rtl"}fail [להעביר
פרוצדורות שמבצעות מניפולציות אחרות על התוצאה -- כל זאת מבלי לשנות שורה
אחת בקוד הקיים של]{dir="rtl"} replace-leaves\$[. לדוגמה:]{dir="rtl"}

**[שאלה 4]{dir="rtl"} -- []{dir="rtl"}continuation [עם מספר
ארגומנטים]{dir="rtl"}**

[פרוצדורות ה-]{dir="rtl"}CPS [ שאנו יוצרים, למעשה אינן בעצמן מחשבות את
התוצאה, אלא מייצרות (על ידי יצירת]{dir="rtl"} continuations[) פרוצדורה
המהווה את תהליך החישוב. אם נקפיד לייצר]{dir="rtl"} continuations [אשר
מקבלים מספר ארגומנטים ובאופן עקבי נפעיל אותם על אותו מספר של ארגומנטים,
נוכל לומר שתהליך החישוב שנייצר \"מחזיר\" מספר ערכים.]{dir="rtl"}

[נראה להלן פרוצדורה בה תכונה זו שימושית. הפרוצדורה מפצלת רשימה נתונה
לשתי רשימות לפי פרדיקט פרימיטיבי,]{dir="rtl"} pred[.
ה-]{dir="rtl"}continuation [מקבל שני ארגומנטים: רשימת האיברים מן הבעיה
המוקטנת אשר קיימו את הפרדיקט ורשימת אלו שלא. על שתי הרשימות יתבצע המשך
החישוב.]{dir="rtl"}

**[\
]{dir="rtl"}**

**[דוגמאות נוספות לעיון]{dir="rtl"}**

# [שאלה 1 -- \"7 בום\"]{dir="rtl"}

[נייצר את הרשימה העצלה שאיבריה מתאימים לחוקי המשחק 7 בום]{dir="rtl"}:

**[שאלה 2]{dir="rtl"} -- [רקורסיה הדדית עם]{dir="rtl"} CPS**

[\
]{dir="rtl"}

[כאשר נרצה להמיר פונקציות רקורסיביות הדדיות ל-]{dir="rtl"}CPS[, נמיר את
כולן ל-]{dir="rtl"}CPS[.]{dir="rtl"}

[**נשים לב:** על שתי הפונקציות להיות כתובות בצורת]{dir="rtl"} CPS[. אם
היינו משתמשים ב-]{dir="rtl"} even?\$[יחד עם]{dir="rtl"} odd [שאינה כתובה
כ-]{dir="rtl"}CPS [(ובהנחה ש-]{dir="rtl"}odd [שוב קוראת
ל-]{dir="rtl"}even?\$[), היינו \"זורקים\" את ה-]{dir="rtl"}continuation
[שהצטבר בכל פעם שהיינו קוראים ל-]{dir="rtl"}even?\$ [מתוך]{dir="rtl"}
odd [(כיוון ש-]{dir="rtl"}odd [אינה כתובה בצורת]{dir="rtl"} CPS[, היא
אינה מקבלת]{dir="rtl"} continuation [כארגומנט ולכן גם לא
מעבירה]{dir="rtl"} continuation[).]{dir="rtl"}

**[שאלה 3]{dir="rtl"} -- [גרסת]{dir="rtl"} CPS [עבור פרוצדורה למציאת
מחלק משותף מקסימאלי (]{dir="rtl"}gcd[)]{dir="rtl"}**

> [\
> נתחיל בבחינת הפרוצדורה בה תהליך החישוב הוא איטרטיבי:]{dir="rtl"}

[\
]{dir="rtl"}

> [כתיבת גרסת ה-]{dir="rtl"}CPS [היא מידית: ה-]{dir="rtl"}continuation
> [יוכל להישאר]{dir="rtl"} id [(כלומר ללא שינוי) לאורך כל החישוב. זאת,
> כיוון ש-]{dir="rtl"}n [משמש כ-\"צובר\" לתשובה במקרה זה. נבחין כי למעשה
> איננו מרחיבים את הפונקציה \"הנשלחת\" כ -]{dir="rtl"} continuation
> [במהלך ריצת]{dir="rtl"} gcd[\$:]{dir="rtl"}

**[שאלה 4]{dir="rtl"} -- [גרסת]{dir="rtl"}CPS [עבור פרוצדורה לחישוב אורך
רשימה\
]{dir="rtl"}**

> [נבחן תחילה את המימוש של]{dir="rtl"} length[, המחשבת את אורכה של
> רשימה:]{dir="rtl"}
>
> [ובגרסת]{dir="rtl"} CPS[:]{dir="rtl"}
>
> [הרעיון הוא להניח כי אל המשתנה]{dir="rtl"} cdr-length [\"יוכנס\" האורך
> של זנב הרשימה (זאת כיוון שקראנו רקורסיבית לפונקציה]{dir="rtl"}
> length\$ [עם (]{dir="rtl"}cdr lst[)). כלומר אנו מניחים כי]{dir="rtl"}
> cdr-length [חושב וכל שנותר הוא להפעיל את ה-]{dir="rtl"}continuation
> [על התוצאה שהיא אורך הרשימה כולה (אורך זנב הרשימה + 1). נבחין כי בכל
> שלב באיטרציה נוצרת פונקציית]{dir="rtl"} continuation [חדשה (מורחבת)
> פרט לשלב האחרון (מקרה הבסיס).]{dir="rtl"}
>
> [נשים לב: השימוש ב-]{dir="rtl"}CPS [אינו חוסך באופן כללי את הזיכרון
> הנדרש, אלא רק חוסך את השימוש במקום על המחסנית. למעשה, העברנו את השימוש
> בזיכרון בכל איטרציה מן המחסנית אל ה-]{dir="rtl"}heap
> [(ה-]{dir="rtl"}continuations [הם]{dir="rtl"} closures [והם מיוצרים על
> ה-]{dir="rtl"}heap[).]{dir="rtl"}

**[שאלה]{dir="rtl"} 5 []{dir="rtl"}-- [גרסת]{dir="rtl"} CPS [עבור
פרוצדורות מסדר גבוה (]{dir="rtl"}map\$\$[)]{dir="rtl"}**

[אם אנו מניחים כי פרוצדורות המיפוי]{dir="rtl"} f [המתקבלת כארגומנט היא
פרימיטיבית (ואינה כתובה בצורת]{dir="rtl"} CPS[):]{dir="rtl"}

> [כיוון שהפרוצדורה]{dir="rtl"} f [אינה כתובה בגרסת]{dir="rtl"} CPS[,
> הפעלנו את]{dir="rtl"} c [על]{dir="rtl"} (cons (f (car lst))
> mapped-cdr)[. כעת, נניח כי]{dir="rtl"} f [אינה פרימיטיבית, ולכן הומרה
> לגרסת ה]{dir="rtl"} CPS [שלה,]{dir="rtl"} f\$[. נראה כיצד לכתוב את
> גרסת ה-]{dir="rtl"}CPS [של]{dir="rtl"} map[, כאשר הפרוצדורה אותה
> מפעילים על כל אחד מאיברי הרשימה,]{dir="rtl"} f\$[, נתונה בעצמה
> בגרסת]{dir="rtl"} CPS[:]{dir="rtl"}

[\
]{dir="rtl"}

> [נתבונן ב-]{dir="rtl"}continuation [שנבנה לאורך החישוב:]{dir="rtl"}

map\$\$ [מפעילה את]{dir="rtl"} f\$ [על אברי הרשימה מהסוף להתחלה
(בדוגמה]{dir="rtl"} 5 → 4 → 3 → 2 → 1[). הפעלת]{dir="rtl"} f [והקריאה
ל-]{dir="rtl"}map [אינן תלויות (אינן מקוננות זו בזו) ולכן ניתן לבחור מה
יתרחש קודם בגרסת ה]{dir="rtl"} CPS[. כך נקבע את הסדר בו
תופעל]{dir="rtl"} f\$ [על אברי הרשימה (מההתחלה לסוף או להיפך). הגרסה
הבאה מפעילה את]{dir="rtl"} f\$ [על אברי הרשימה לפי הסדר הרגיל של מההתחלה
לסוף:]{dir="rtl"}

[\
]{dir="rtl"}

**[שאלה]{dir="rtl"} 6 [-- עצירת החישוב]{dir="rtl"}**

[הפונקציה]{dir="rtl"} mul-list\$ [מקבלת רשימה של רשימות ומחזירה מכפלה של
כל המספרים ברשימה. אם יש מופע אטומי שאינו מספר אז יש לעצור את
החישוב.]{dir="rtl"}
