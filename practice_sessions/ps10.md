<h1><b>Lazy-Lists and Continuation Passing Style (CPS)</b></h1>

<h2><b>Practical Session - Week #10</b></h2>

# Lists-Lazy

×ª×–×›×•×¨×ª: ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª ×”×Ÿ ×ž×‘× ×™ × ×ª×•× ×™× ×¡×“×¨×ª×™×™× ×”×ž××¤×©×¨×™× ×“×—×™×™×” ×©×œ ×—×™×©×•×‘ ×•×©×ž×™×¨×” ×©×œ ××™×‘×¨×™× ×ž×ª×•×›×.
×”×™×ª×¨×•× ×•×ª ×‘×©×™×ž×•×© ×‘×”×Ÿ:
* ××™×Ÿ ×¦×•×¨×š ×œ××—×¡×Ÿ ×‘×–×™×›×¨×•×Ÿ ××ª ×›×œ ××™×‘×¨×™ ×”×¨×©×™×ž×”. ×‘×¢×–×¨×ª ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª × ×™×ª×Ÿ ×œ×™×™×¦×’ ××£ ×¡×“×¨×•×ª ××™× ×¡×•×¤×™×•×ª.
* ×“×—×™×™×ª ×—×™×©×•×‘ ××™×‘×¨×™× ×‘×¨×©×™×ž×” ×œ×–×ž×Ÿ ×‘×• × ×“×§×§ ×œ×”× â€“ ×™×™×ª×›×Ÿ ×©×œ× × ×–×“×§×§ ×œ×›×œ ××™×‘×¨×™ ×”×¨×©×™×ž×”.

× ×’×“×™×¨ ××ª ×¢×¨×›×™ ×”×˜×™×¤×•×¡ ×©×œ ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª ×‘××•×¤×Ÿ ×¨×§×•×¨×¡×™×‘×™:

```typescript
LzL = { empty-lzl } âˆª (Scheme-Type Ã— [Empty â†’ LzL])
```
×–×”×• ADT ×¢×‘×•×¨ ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª (×”×ž×™×ž×•×© ×ž×•×¤×™×¢ ×‘×¡×¤×¨ ×”×§×•×¨×¡):

```typescript
; Signature: cons-lzl(x, f)
; Type: [T * [Empty -> LzL] -> LzL]

; Signature: head(lz-list)
; Type: [LzL -> T]
; Pre-condition: non-empty LzL

; Signature: tail(lz-list)
; Type: [LzL -> LzL]
; Pre-condition: non-empty LzL

; Signature: empty-lzl?(exp)
; Type: [T -> Boolean]

; Signature: nth(lz-list, n)
; Type: [LzL * Number -> T]

; Signature: take(lz-list, n)
; Type: [LzL * Number -> List]
```

## ×©××œ×” 1 â€“ ×”×©×¢×¨×ª ×§×•×œ×¥
× ×’×“×™×¨ ××ª ×”×¤×•× ×§×¦×™×”:

![collatz](./resources/ps10/collatz%20exmple.png)
{: .c}

×”×©×¢×¨×ª ×§×•×œ×¥ ×’×•×¨×¡×ª ×›×™ ×œ×›×œ n>1 ×ž×ª×§×™×™× ×›×™ ×”×¡×“×¨×” n,f(n),f(f(n)),f(f(f(n)))â€¦ ×ª×ž×™×“ ×ž×ª×›× ×¡×ª ×‘-1. 
×œ×ž×©×œ ×¢×‘×•×¨ n=563: 

563 -> 1690 -> 845 -> 2536 -> 1268 -> 634 -> 317 -> 952 -> 476 -> 238 -> 119 -> 358 -> 179 -> 538 -> 269 -> 808 -> 404 -> 202 -> 101 -> 304 -> 152 -> 76 -> 38 -> 19 -> 58 -> 29 -> 88 -> 44 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1

× ×¨×¦×” ×œ×”×’×“×™×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×”×ž×›×™×œ×” ××ª ×¡×“×¨×ª ×§×•×œ×¥ ×¢×‘×•×¨ n ×›×œ×©×”×•.

```typescript
; Signature: lzl-collatz(n)
; Type: [Number -> LzL(Number)]
; Purpose: Generate the (possibly infinite) series { n, f(n), f(f(n)), ... },
; where f(n) is collatz function
; Pre-condition: n is a natural number greater than zero
(define lzl-collatz
    (lambda (n)
        (if (< n 2)
            (cons-lzl n (lambda () empty-lzl))
            (cons-lzl n
                (lambda ()
                    (if (= (modulo n 2) 0)
                        (lzl-collatz (/ n 2))
                        (lzl-collatz (+ (* 3 n) 1))))))))
> (take (lzl-collatz 563) 44)
'(563 1690 845 2536 1268 634 317 952 476 238 119 358 179 538 269 808 404 202
101 304 152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)
```
×ž×” ×”×˜×™×¤×•×¡ ×©×œ lzl-collatz? ×”×× ×”×¤×¨×•×¦×“×•×¨×” ×”×™× well-typed? ×”×× ```(head (lzl-collatz n))``` ×¢×‘×•×¨ n ×˜×‘×¢×™ ×›×œ×©×”×™ ×ª×ž×™×“ ×ª×¦×œ×™×—?


## ×©××œ×” 2 â€“ ×¡×“×¨×ª ×”×”×¤×¢×œ×•×ª ×”×¢×¦×ž×™×•×ª

×‘×”×™× ×ª×Ÿ ×¤×•× ×§×¦×™×” ![equation 1](https://render.githubusercontent.com/render/math?math=f) ×•×¢×¨×š ![equation 2](https://render.githubusercontent.com/render/math?math=x) , × ×’×“×™×¨ ××ª ×¡×“×¨×ª ×”×”×¨×›×‘×•×ª ×”×¢×¦×ž×™×•×ª ×œ×”×™×•×ª ![equation 3](./resources/ps10/sequence.png) . ×”×¡×“×¨×”
×™×›×•×œ×” ×œ×”×™×•×ª ×¡×•×¤×™×ª, ××• ××™× ×¡×•×¤×™×ª. × ×¨×¦×” ×œ×™×™×¦×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×©××™×‘×¨×™×” ×”× ××™×‘×¨×™ ×”×¡×“×¨×”. ×”×¨×©×™×ž×” ×ª×™×’×ž×¨ ×›××©×¨
×”×’×™×¢×” ×œ× ×§×•×“×ª ×©×‘×ª, ×›×œ×•×ž×¨ ×›××©×¨ ×”×¢×¨×š ×”×ž×•×—×–×¨ ×ž×”×¤×¢×œ×ª ![equation 4](https://render.githubusercontent.com/render/math?math=f) ×”×•× ××•×ª×• ×”×¢×¨×š ×©×¢×œ×™×• ![equation 5](https://render.githubusercontent.com/render/math?math=f) ×”×•×¤×¢×œ×”.

```typescript
; Signature: lzl-apply(f, x)
; Type: [[T -> T] * T -> LzL]
; Purpose: Generate the self-application series of f on x
(define lzl-apply
    (lambda (f x)
        (let ((fx (f x)))
            (if (= fx x)
                (cons-lzl x (lambda () empty-lzl))
                (cons-lzl x (lambda () (lzl-apply f fx)))))))
> (take (lzl-apply (lambda (x) (+ 1 (/ 1 x))) 1.0) 100)
'(1.0 2.0 1.5 1.6666666666666665 1.6 1.625 ... 1.6180339887498951)
                             ð‘™ð‘’ð‘›ð‘”ð‘¡â„Ž = 38

> (take (lzl-apply (lambda (x) x) 1) 100)
'(1)

```
# Continuation Passing Style (CPS) 

×¤×¨×“×™×’×ž×” ×ª×›× ×•×ª×™×ª ×‘×” ×œ×›×œ ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© × ×™×ª×Ÿ ×¤×¨×ž×˜×¨ × ×•×¡×£ ×©×”×™× ×• ×¤×¨×•×¦×“×•×¨×”, ××©×¨ ×ž×”×•×•×” ××ª ×”×ž×©×š ×”×—×™×©×•×‘ ×©×™×© ×œ×‘×¦×¢ ×‘×ª×•× ×¤×¢×•×œ×ª ×¤×¨×•×¦×“×•×¨×ª ×”×ž×©×ª×ž×© (×•×¢×œ ×›×Ÿ × ×§×¨× ×”×¤×¨×ž×˜×¨ continuation). ×—×œ×§ ×ž×Ÿ ×”×ž×•×˜×™×‘×¦×™×” ×œ×©×™×ž×•×© ×‘×¤×¨×“×™×’×ž×ª ×ª×›× ×•×ª ×–×• ×”×™× ×”×©×œ×™×˜×” ×©×”×™× ×ž××¤×©×¨×ª ×‘×‘×§×¨×” ×©×œ ×”×ª×•×›× ×™×ª:

1.	×‘×ž×”×œ×š ×›×ª×™×‘×ª ×¤×¨×•×¦×“×•×¨×•×ª ×ž×©×ª×ž×© ×‘×©×™×˜×ª CPS, ×›×œ ×§×¨×™××” ×¨×§×•×¨×¡×™×‘×™×ª × ×›×ª×‘×ª ×›×š ×©×”×™× ×‘×¢×ž×“×ª ×–× ×‘. ×œ×›×Ÿ, ×ž×¢×¦× ×”×©×™×ž×•×© ×‘×©×™×˜×”, ×”×¤×¨×•×¦×“×•×¨×” ×ª×™×™×¦×¨ ×ª×”×œ×™×š ××™×˜×¨×˜×™×‘×™.
2. ×©×™×˜×ª	CPS ×ž××¤×©×¨×ª ×œ×©×œ×•×˜ ×‘×¡×“×¨ ×œ×¤×™×• ×”×ª×•×›× ×™×ª ×ª×—×©×‘ ×‘×™×˜×•×™×™×. ×œ×ž×©×œ, ×× × ×ž×ž×© ×—×™×¤×•×© ×‘×¢×¥, × ×•×›×œ ×œ×‘×—×•×¨ ×× ×œ×—×¤×© ×§×•×“× ×‘×¢× ×£ ×”×™×ž× ×™ ××• ×‘×©×ž××œ×™ (×œ×¢×•×ž×ª ×–××ª, ×œ×œ× CPS × ×”×™×™×” ×ª×œ×•×™×™× ×‘×¡×“×¨ ×”×¢×¨×›×ª ×”×‘×™×˜×•×™×™× ×”×ž×•×‘× ×” ×‘-interpreter).
3.	×”×©×œ×™×˜×” ×‘×‘×§×¨×ª ×”×ª×•×›× ×™×ª ×ž××¤×©×¨×ª ×œ× ×§×•×˜ ×‘×¤×¢×•×œ×” ×©×•× ×” ×‘×ž×§×¨×” ×©×œ ×”×¦×œ×—×” / ×›×™×©×œ×•×Ÿ ××• ×™×¦×™××” ×™×©×™×¨×” (exception) ×‘×ž×”×œ×š ×¨×§×•×¨×¡×™×” (××• ××™×˜×¨×¦×™×”) ×•×›×Ÿ ×ž××¤×©×¨×ª ×œ×”×—×–×™×¨ ×›×ž×” ×¢×¨×›×™× ×‘×™×—×“. 

## ×©××œ×” 1 â€“ ××•×¤×Ÿ ×¤×¢×•×œ×ª ×¤×¨×•×¦×“×•×¨×” ×‘×’×¨×¡×ª CPS ×•×”×•×›×—×ª × ×›×•× ×•×ª

× ×™×–×›×¨ ×‘×ž×™×ž×•×© ×©×œ ×”×¤×¨×•×¦×“×•×¨×” fact ×œ×œ× ×©×™×ž×•×© ×‘-CPS:


```typescript
; Type: [Number -> Number]
; Purpose: To calculate the factorial of n.
(define fact
    (lambda (n)
        (if (= n 0)
            1
            (* n (fact (- n 1))))))
```
×›×¢×ª, × ×ž×ž×© ××ª fact ×‘×©×™×˜×ª CPS ×•× ×ž×—×™×© ××ª ××•×¤×Ÿ ×”×¤×¢×•×œ×” ×©×œ×”:
```typescript
; Type: [Number * [Number->T1] -> T1]
; Purpose: Returns the application of the
; continuation c on the factorial of n.
(define fact$
    (lambda (n c)
        (if (= n 0)
            (c 1)
            (fact$ (- n 1)
                (lambda (fact_n-1)
                    (c (* n fact_n-1)))))))
> (fact 5)
120
> (fact$ 5 add1)
121
```
×“×™×•×Ÿ: ×ž×“×•×¢ ×”×ª×•×¦××•×ª ××™× ×Ÿ ×–×”×•×ª? ×›×™×¦×“ × ×¨×¦×” ×œ×§×‘×•×¢ ×‘×“×¨×š ×›×œ×œ ××ª ×¤×¨×•×¦×“×•×¨×ª ×”-continuation ×©× ×¢×‘×™×¨ ×œ×§×¨×™××” ×”×¨××©×•× ×”?

### ×”×•×›×—×ª × ×›×•× ×•×ª:
 ×œ××—×¨ ×”×ž×¨×ª ×¤×¨×•×¦×“×•×¨×” ×œ×’×¨×¡×ª ×”-CPS ×©×œ×”, × ×“×¨×©×ª ×”×•×›×—×ª × ×›×•× ×•×ª. ×”× ×›×•× ×•×ª × ×©×¢× ×ª ×¢×œ ×”×¦×’×ª ×©×§×™×œ×•×ª ×‘×™×Ÿ ×©×ª×™ ×”×’×¨×¡××•×ª, ×‘×ž×•×‘×Ÿ ×”×‘×: ×‘×”×¤×¢×œ×ª ×”××œ×’×•×¨×™×ª× applicative-eval ×¢×œ ×§×¨×™××” ×ž×ª××™×ž×” ×œ×›×œ ××—×ª ×ž×Ÿ ×”×’×¨×¡××•×ª, ×”×—×™×©×•×‘ ×™×¡×ª×™×™× ×•×™×•×—×–×¨ ×¢×¨×š ×–×”×”. ×œ×©× ×›×š, × ×–×“×§×§ ×œ×”×’×“×¨×ª ×”×©×§×™×œ×•×ª ×”×‘××”:

×”×’×“×¨×”: ×¤×¨×•×¦×“×•×¨×” \$f ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” f ×× ×œ×›×œ ×¢×¨×›×™ ×§×œ×˜ x1,x2,â€¦,x3 ×•×œ×›×œ continuation ×”×ž×¡×•×ž×Ÿ cont, ×ž×ª×§×™×™×:
```typescript
(f$ x1 â€¦ xn cont) = (cont (f x1 â€¦ xn))
```
×˜×¢× ×”: ×”×¤×¨×•×¦×“×•×¨×” \$fact ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” fact. ×›×œ×•×ž×¨, ×œ×›×œ ×ž×¡×¤×¨ ×˜×‘×¢×™, n, ×•×œ×›×œ continuation, ××©×¨ ×™×¡×•×ž×Ÿ ×¢×œ ×™×“×™ c, ×ž×ª×§×™×™×:  
```typescript
(fact$ n c) = (c (fact n))
```
×”×•×›×—×”: ×›×™×•×•×Ÿ ×©×”×¤×¨×•×¦×“×•×¨×” fact ×”×™× ×¨×§×•×¨×¡×™×‘×™×ª, ×”×”×•×›×—×” ×ž×ª×‘×¦×¢×ª ×¢×œ ×™×“×™ ×©×™×ž×•×© ×‘××™× ×“×•×§×¦×™×”.

×‘×¡×™×¡ ×”××™× ×“×•×§×¦×™×”: n=0
```typescript
a-e[ (fact$ 0 c) ] ==>* a-e[ (c 1) ] = a-e[ (c (fact 0)) ]
```
(×”×¡×™×ž×•×Ÿ a-e ×”×•× ×§×™×¦×•×¨ ×¢×‘×•×¨ applicative-eval)

×”× ×—×ª ×”××™× ×“×•×§×¦×™×”: ×¢×‘×•×¨ n=kâˆˆ N ×”×˜×¢× ×” ×ž×ª×§×™×™×ž×ª ×œ×›×œ kâ‰¥i. ×›×œ×•×ž×¨
```typescript
(fact$ i c) = (c (fact i))
```
×¦×¢×“ ×”××™× ×“×•×§×¦×™×”: ×™×”× n=k+1,kâˆˆN, ××–×™:
```typescript
a-e [ (fact$ n c) ] ==>*
a-e [ (fact$ (- n 1) (lambda (res) (c (* n res)))) ] ==>*
```

×ž×”× ×—×ª ×”××™× ×“×•×§×¦×™×”, × ×§×‘×œ:
```typescript
a-e [ ((lambda (res) (c (* n res))) (fact (- n 1))) ] ==>*
a-e [ (c (* n (fact (- n 1)))) ] =
a-e [ (c (fact n)) ]
```


## ×›×œ×œ×™ ××¦×‘×¢ ×œ×”×ž×¨×ª ×¤×¨×•×¦×“×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª ×œ×¤×¨×•×¦×“×•×¨×” ×©×§×•×œ×”-CPS:

×‘×”×™× ×ª×Ÿ ×¤×¨×•×¦×“×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª, f, ×¢× ×”×¤×¨×ž×˜×¨×™× ×”×¤×•×¨×ž××œ×™×™× x1,â€¦,xn, ×¤×¨×•×¦×“×•×¨×” ×©×§×•×œ×”-CPS ×œ×” ×ª×¡×•×ž×Ÿ \$f ×•×ª×•×¤×¢×œ ×¢×œ ××¨×’×•×ž× ×˜ × ×•×¡×£, c, ×”-continuation. ×”×¢×§×¨×•× ×•×ª ×©×™× ×—×• ××•×ª× ×• ×‘×›×ª×™×‘×ª \$f ×”× ×›×“×œ×§×ž×Ÿ:

×. × ×¤×¢×™×œ ××ª c ×¢×œ ×¢×¨×›×™× ×ž×•×—×–×¨×™× (×›×—×œ×§ ×ž×ž×§×¨×” ×”×‘×¡×™×¡, ××• ×‘×ª×•×š continuation ×”× ×•×¦×¨ ×‘×ž×”×œ×š ×”×¨×™×¦×”). 

×‘.	× ×§×¤×™×“ ×œ×›×ª×•×‘ ×›×œ ×§×¨×™××” ×œ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© ×‘×ª×•×š \$f ×›×š ×©×”×§×¨×™××” ×ª×”×™×” ×‘×¢×ž×“×ª ×–× ×‘.

×’.	×›×ª×™×‘×ª ×”-continuation:

    a. ×›×©× ×‘×¦×¢ ×‘×ª×•×š \$f ×§×¨×™××” ×¨×§×•×¨×¡×™×‘×™×ª ×›×œ×©×”×™  ×¢× ××¨×’×•×ž× ×˜×™× x1,â€¦,xn, × ×ª×‘×¡×¡ ×¢×œ ×”× ×—×ª ×”××™× ×“×•×§×¦×™×” (×”×ž×§×˜×™× ×” ××ª ×”×‘×¢×™×”). ×›×œ×•×ž×¨, × × ×™×— ×›×™ ×”×ª×©×•×‘×” ×¢×‘×•×¨ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª ×ž×ª×§×‘×œ×ª ×›××¨×’×•×ž× ×˜ ×©×œ
×”-continuation.

    b. ×‘×›×ª×™×‘×ª ×”-continuation, × ×§×™×™× ××ª ×¦×¢×“ ×”××™× ×“×•×§×¦×™×” ×•× ×¤×¢×œ ×¢×œ ×”×¤×ª×¨×•×Ÿ ×¢×‘×•×¨ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª ×›×“×™ ×œ×§×‘×œ ××ª ×”×¤×ª×¨×•×Ÿ ×œ×‘×¢×™×” ×”×’×“×•×œ×” ×™×•×ª×¨.

×“.	×‘×›×ª×™×‘×ª ×¤×¨×•×¦×“×•×¨×” ×‘×©×™×˜×ª CPS, × ×§×¤×™×“ ×©×›×œ ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© (×œ× ×¤×¨×™×ž×™×˜×™×‘×™×ª) ×”×ž×©×ž×©×ª ××ª \$f ×ª×”×™×” ×’× ×”×™× ×›×ª×•×‘×” ×‘×©×™×˜×ª CPS.

×”.	×‘×“×¨×š ×›×œ×œ, ×œ× × ×¨×¦×” ×œ×‘×¦×¢ ×ž× ×™×¤×•×œ×¦×™×” ×¢×œ ×”×¢×¨×š ×”×ž×•×—×–×¨ ×©×œ ×”×¤×•× ×§×¦×™×” ×•×œ×›×Ÿ × ×©×ª×ž×© ×‘×¤×•× ×§×¦×™×™×ª ×”×–×”×•×ª id
×›-continuation ×”×”×ª×—×œ×ª×™.

## ×©××œ×” 2 â€“ ×¤×•× ×§×¦×™×•×ª CPS ×ž×¡×“×¨ ×’×‘×•×”

× ×ž×™×¨ ××ª ×”×¤×•× ×§×¦×™×” foldr ×œ-CPS. ×ª×–×›×•×¨×ª:


```typescript
(foldr op initial (list x1 x2 ... xn))
                â‡•
(op x1 (op x2 (op ... (op xn initial))))
```


```typescript
; Signature: foldr(op, initial, sequence)
; Type: [ [ T1 * T2 -> T2 ] * T2 * List(T1) -> T2 ]
; Example: (foldr + 0 (list 1 2 3 4 5)) => 15
(define foldr
  (lambda (op initial sequence)
    (if (empty? sequence)
        initial
        (op (car sequence)
            (foldr op initial (cdr sequence)))))) 

; Signature: foldr$(op, initial, sequence, c)
; Type: [ [T1 * T2 -> T2] * T2 * List(T1) * [T2 -> T3] -> T3 ]
; Example: (foldr$ * 1 (list 1 2 3 4 5)
;                  (lambda (result) (cons 'the-product result)))
 ;          => '(the-product . 120)
(define foldr$
  (lambda (op initial sequence c)
    (if (empty? sequence)
        (c initial)
        (foldr$ op
                initial
                (cdr sequence)
                (lambda (acc-cdr-res)
                  (c (op (car sequence) acc-cdr-res)))))))

; Signature: foldr$$(op$, initial, sequence, c)
; Type: [ [T1 * T2 * [T2->T3] -> T3] * T2 * List(T1) * [T2->T3] -> T3 ]
; Example: (foldr$ +$ 0 (list 1 2 3 4 5) 
;                 (lambda (result) (cons 'the-sum result)))
;           => '(the-sum . 15)
(define foldr$$
  (lambda (op$ initial sequence c)
    (if (empty? sequence)
        (c initial)
        (foldr$$ op$ 
                 initial
                 (cdr sequence)
                 (lambda (acc-cdr-res)
                   (op$ (car sequence) acc-cdr-res c))))))

```
 

× ×©×™× ×œ×‘: ×ž×“×•×¢ ×œ× ×™×›×•×œ× ×• ×œ×”×¤×¢×™×œ ××ª c ×¢×œ ×ª×•×¦××ª \$op ×‘×ž×§×•× ×œ×”×¢×‘×™×¨ ×œ×” ××ª c ×›××¨×’×•×ž× ×˜? ×¨××©×™×ª, ×œ×• ×¢×©×™× ×• ×›×š, ×”×§×¨×™××” ×œ× ×”×™×™×ª×” ×‘×¢×ž×“×ª ×–× ×‘. ×‘× ×•×¡×£, ×”×‘×¢×™×” ×”×ž×”×•×ª×™×ª ×™×•×ª×¨ ×”×™× ×©×‘×ž×§×¨×” ×›×–×” ×”×™×™× ×• ×ž××‘×“×™× ××ª ×”×©×œ×™×˜×” ×¢×œ ×ª×”×œ×™×š ×”×—×™×©×•×‘ ×”×ž×’×•×œ×ž×ª ×‘×ª×•×š ×”-continuation. 

## ×©××œ×” 3 â€“ ×¢×¦×™×¨×ª ×”×—×™×©×•×‘
×”×¤×•× ×§×¦×™×” \$mul-list ×ž×§×‘×œ×ª ×¨×©×™×ž×” ×©×œ ×¨×©×™×ž×•×ª ×•×ž×—×–×™×¨×” ×ž×›×¤×œ×” ×©×œ ×›×œ ×”×ž×¡×¤×¨×™× ×‘×¨×©×™×ž×”. ×× ×™×© ×ž×•×¤×¢ ××˜×•×ž×™
×©××™× ×• ×ž×¡×¤×¨ ××– ×™×© ×œ×¢×¦×•×¨ ××ª ×”×—×™×©×•×‘.

![mul-list](./resources/ps10/mul-list.png)

## ×©××œ×” 4 â€“ ×©×™×ž×•×© ×‘×ž×¡×¤×¨ continuations

×œ×¦×•×¨×š ×”×¤×©×˜×ª ×”×¢×‘×•×“×” ×ž×•×œ ×¨×©×™×ž×•×ª, × ×©×ª×ž×© ×‘-ADT ×¢×‘×•×¨ ×¢×¦×™× (×”×ž×™×ž×•×© ×ž×•×¤×™×¢ ×‘×¡×¤×¨ ×”×§×•×¨×¡). ×›×¤×™ ×©×›×‘×¨ ×¨××™× ×• ×‘×¢×‘×¨ ×¢×‘×•×¨ ×¨×©×™×ž×•×ª ×•×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª, ×’× ×¢×¥ ×ž×•×’×“×¨ ×‘×¦×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª:
1.	Empty-Tree is a Tree
2.	if t is a Tree, than for every e: the value of  (add-subtree (make-leaf e) t) is a Tree

×ž×ž×©×§ ×”-ADT:

```typescript
; Signature: make-tree(1st, ..., nth)
; Type: [Tree * ... * Tree -> Tree]

; Signature: add-subtree(subtree, tree)
; Type: [Tree * Tree -> Tree]

; Signature: make-leaf(data)
; Type: [T -> Tree]

; Signature: empty-tree
; Type: Empty-Tree

; Signature: first-subtree(tree)
; Type: [Tree -> Tree]

; Signature: rest-subtrees(tree)
; Type: [Tree -> Tree]

; Signature: leaf-data(leaf)
; Type: [Tree -> T]

; Signature: composite-tree?(e)
; Type: [T -> Boolean]

; Signature: leaf?(e)
; Type: [T -> Boolean]

; Signature: empty-tree?(e)
; Type: [T -> Boolean]

```

×”×¤×•× ×§×¦×™×” \$replace-leaves ×ž×§×‘×œ×ª ×¢×¥ ×”×•×ž×•×’× ×™, ×¤×¨×“×™×§×˜ (×©××™× ×• ×›×ª×•×‘ ×‘×’×¨×¡×ª CPS), ×‘×™×˜×•×™ new ×ž×˜×™×¤×•×¡ ×¢×œ×™ ×”×¢×¥ ×•×©× ×™ continuations: ××—×“ ×¢×‘×•×¨ ×”×¦×œ×—×” ×•×”×©× ×™ ×¢×‘×•×¨ ×›×™×©×œ×•×Ÿ. ×”×ž×˜×¨×” ×”×™× ×œ×”×—×œ×™×£ ××ª ×›×œ ×”×¢×œ×™× ××©×¨ ×ž×§×™×™×ž×™× ××ª ×”×¤×¨×“×™×§×˜, ×‘×‘×™×˜×•×™ new. × ×©×™× ×œ×‘ ×©× ×™×ª×Ÿ ×œ×”×›×œ×™×œ ××ª ×”×§×•×“ ×¢"×™ ×”×¢×‘×¨×ª ×¤×¨×•×¦×“×•×¨×” ×‘×ª×•×¨ new ×•×œ×©× ×•×ª ××ª ×”×¢×œ×” ×‘×¦×•×¨×” ×“×™× ×ž×™×ª.
 
![replace-leaves](./resources/ps10/replace-leaves.png)

```typescript
> (define tree (make-tree (make-tree (make-leaf 1) (make-leaf 2))
                          (make-tree (make-leaf 3) (make-leaf 4)
                                     (make-tree (make-leaf 5)))))

> (replace-leaves$ tree even? 42 (lambda (x) x) (lambda () tree))
'((1 42) (3 42 (5)))

```

×”×¢×¨×”: ×™×›×•×œ× ×• ×‘×ž×§×•× succ ×•-fail ×œ×”×¢×‘×™×¨ ×¤×¨×•×¦×“×•×¨×•×ª ×©×ž×‘×¦×¢×•×ª ×ž× ×™×¤×•×œ×¦×™×•×ª ××—×¨×•×ª ×¢×œ ×”×ª×•×¦××” â€“ ×›×œ ×–××ª ×ž×‘×œ×™ ×œ×©× ×•×ª ×©×•×¨×” ××—×ª ×‘×§×•×“ ×”×§×™×™× ×©×œ \$replace-leaves. ×œ×“×•×’×ž×”:

```typescript
> (replace-leaves$ tree
                   (lambda (x) (> x 100))
                   42
                   (lambda (x) x)
                   (lambda ()
                     (replace-leaves$ tree
                                      odd?
                                      0
                                      permutations
                                      (lambda () 'I-give-up))))
'(((0 2) (0 4 (0))) ((0 4 (0)) (0 2)))

```

```typescript
> (replace-leaves$ tree
                    (lambda (x) (> x 100))
                    (lambda(x)x)
                    (lambda (x) x)
                    (lambda ()
                        (replace-leaves$ tree
                            odd?
                            (lambda(x)(+ 1 x))
                            (lambda(x)(rest-subtree x)
                            (lambda()'failled)
                        )
)
'((4 4) (6)))
```

```typescript
> (replace-leaves$ tree
                (lambda (x) (> x 100))
                (lambda(x)(* 2 x))
                (lambda (x) x)
                (lambda ()
                    (replace-leaves$ tree
                        zero?
                        (lambda(x)(+ 1 x))
                        (lambda(x)(rest-subtree x)
                        (lambda() (error "failled to replace anyting"))
                    )
)
This raise exception
Error "failed to replace anything"
```


## ×©××œ×” 5 â€“ continuation ×¢× ×ž×¡×¤×¨ ××¨×’×•×ž× ×˜×™×

×¤×¨×•×¦×“×•×¨×•×ª ×”-CPS  ×©×× ×• ×™×•×¦×¨×™×, ×œ×ž×¢×©×” ××™× ×Ÿ ×‘×¢×¦×ž×Ÿ ×ž×—×©×‘×•×ª ××ª ×”×ª×•×¦××”, ××œ× ×ž×™×™×¦×¨×•×ª (×¢×œ ×™×“×™ ×™×¦×™×¨×ª continuations) ×¤×¨×•×¦×“×•×¨×” ×”×ž×”×•×•×” ××ª ×ª×”×œ×™×š ×”×—×™×©×•×‘. ×× × ×§×¤×™×“ ×œ×™×™×¦×¨ continuations ××©×¨ ×ž×§×‘×œ×™× ×ž×¡×¤×¨ ××¨×’×•×ž× ×˜×™× ×•×‘××•×¤×Ÿ ×¢×§×‘×™ × ×¤×¢×™×œ ××•×ª× ×¢×œ ××•×ª×• ×ž×¡×¤×¨ ×©×œ ××¨×’×•×ž× ×˜×™×, × ×•×›×œ ×œ×•×ž×¨ ×©×ª×”×œ×™×š ×”×—×™×©×•×‘ ×©× ×™×™×¦×¨ "×ž×—×–×™×¨" ×ž×¡×¤×¨ ×¢×¨×›×™×. 

× ×¨××” ×œ×”×œ×Ÿ ×¤×¨×•×¦×“×•×¨×” ×‘×” ×ª×›×•× ×” ×–×• ×©×™×ž×•×©×™×ª. ×”×¤×¨×•×¦×“×•×¨×” ×ž×¤×¦×œ×ª ×¨×©×™×ž×” × ×ª×•× ×” ×œ×©×ª×™ ×¨×©×™×ž×•×ª ×œ×¤×™ ×¤×¨×“×™×§×˜ ×¤×¨×™×ž×™×˜×™×‘×™, pred. ×”-continuation ×ž×§×‘×œ ×©× ×™ ××¨×’×•×ž× ×˜×™×: ×¨×©×™×ž×ª ×”××™×‘×¨×™× ×ž×Ÿ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª ××©×¨ ×§×™×™×ž×• ××ª ×”×¤×¨×“×™×§×˜ ×•×¨×©×™×ž×ª ××œ×• ×©×œ×. ×¢×œ ×©×ª×™ ×”×¨×©×™×ž×•×ª ×™×ª×‘×¦×¢ ×”×ž×©×š ×”×—×™×©×•×‘.

```typescript
; Signature: split$(pred lst c)
; Type: [ [T1->Boolean] * List(T1) * [List(T1) * List(T1) -> T2] -> T2 ]
; Purpose: Returns the application of the continuation c on two lists:
;          1. A list of members for which the predicate holds. 
;          2. A list of members for which it doesn't.
; Examples: (split$ even? '(1 2 3 4 5 6 7)
;                         (lambda (x y) (list x y)))
;           => '((2 4 6) (1 3 5 7))
(define (split$ pred lst c)
  (if (empty? lst) 
      (c lst lst)
      (split$ pred
              (cdr lst)
              (lambda (cdr-yes-list cdr-no-list)
                (if (pred (car lst))
                    (c (cons (car lst) cdr-yes-list) 
                       cdr-no-list)
                    (c cdr-yes-list 
                       (cons (car lst) cdr-no-list)))))))

> (split$ even?
        '(1 2 3 4 5)
        (lambda (evens odds) (- (foldr + 0 evens) (foldr + 0 odds))))
-3

```

# ×“×•×’×ž××•×ª × ×•×¡×¤×•×ª ×œ×¢×™×•×Ÿ

## ×©××œ×” 1 â€“ "7 ×‘×•×"

× ×™×™×¦×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×©××™×‘×¨×™×” ×ž×ª××™×ž×™× ×œ×—×•×§×™ ×”×ž×©×—×§ 7 ×‘×•×:


```typescript
; Signature: seven-boom(n)
; Type: [Number -> LzL(Number)]
; Pre-condition: n is a natural number
(define seven-boom
  (lambda (n)
    (cons-lzl (cond ((= (modulo n 7) 0) 'boom)
                    ((has-digit? n 7) 'boom)
                    ((= (modulo (sum-digits n) 7) 0) 'boom)
                    (else n))
              (lambda ()
                (seven-boom (+ n 1))))))

> (seven-boom 1)
'(1 . #<procedure>)

> (take (seven-boom 1) 7)
'(1 2 3 4 5 6 boom)

```

## ×©××œ×” 2 â€“ ×¨×§×•×¨×¡×™×” ×”×“×“×™×ª ×¢× CPS

```typescript
; Signature: even?(n)
; Type: [Number -> Boolean]
; Purpose: Returns true if the number n is even, and false otherwise.
; Pre-condition: n >= 0
(define even?
  (lambda (n)
    (if (zero? n)
        #t
        (odd? (sub1 n)))))

; Signature: odd?(n)
; Type: [Number -> Boolean]
; Purpose: Returns true if the number n is odd, and false otherwise.
(define odd?
  (lambda (n)
    (if (zero? n) 
        #f
        (even? (sub1 n)))))

> (even? 7)
#f

```

×›××©×¨ × ×¨×¦×” ×œ×”×ž×™×¨ ×¤×•× ×§×¦×™×•×ª ×¨×§×•×¨×¡×™×‘×™×•×ª ×”×“×“×™×•×ª ×œ-CPS, × ×ž×™×¨ ××ª ×›×•×œ×Ÿ ×œ-CPS.

```typescript
; Signature: even?$(n, c)
; Type: [Number * [Boolean->T1] -> T1]
; Purpose: Returns the application of the continuation c on true if the 
;          number n is even, and the application of
;          c on false otherwise.
(define even?$
  (lambda (n c)
    (if (zero? n) 
        (c #t)
        (odd?$ (sub1 n) c))))

; Signature: odd?$(n, c)
; Type: [Number * [Boolean->T1] -> T1]
; Purpose: Returns the application of the continuation c on true if the 
;          number n is odd, and the application of
;          c on false otherwise.
(define odd?$
  (lambda (n c)
    (if (zero? n) 
        (c #f)
        (even?$ (sub1 n) c))))

> (even?$ 6 id)
#t

```

× ×©×™× ×œ×‘: ×¢×œ ×©×ª×™ ×”×¤×•× ×§×¦×™×•×ª ×œ×”×™×•×ª ×›×ª×•×‘×•×ª ×‘×¦×•×¨×ª CPS .×× ×”×™×™× ×• ×ž×©×ª×ž×©×™× ×‘-\$?even ×™×—×“ ×¢× odd ×©××™× ×” ×›×ª×•×‘×” ×›-
CPS (×•×‘×”× ×—×” ×©-odd ×©×•×‘ ×§×•×¨××ª ×œ-\$?even), ×”×™×™× ×• "×–×•×¨×§×™×" ××ª ×”-continuation ×©×”×¦×˜×‘×¨ ×‘×›×œ ×¤×¢× ×©×”×™×™× ×• ×§×•×¨××™× ×œ-
\$?even ×ž×ª×•×š odd (×›×™×•×•×Ÿ ×©-odd ××™× ×” ×›×ª×•×‘×” ×‘×¦×•×¨×ª CPS ,×”×™× ××™× ×” ×ž×§×‘×œ×ª continuation ×›××¨×’×•×ž× ×˜ ×•×œ×›×Ÿ ×’× ×œ×
×ž×¢×‘×™×¨×” continuation).

## ×©××œ×” 3 â€“ ×’×¨×¡×ª CPS  ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×” ×œ×ž×¦×™××ª ×ž×—×œ×§ ×ž×©×•×ª×£ ×ž×§×¡×™×ž××œ×™ (gcd)

× ×ª×—×™×œ ×‘×‘×—×™× ×ª ×”×¤×¨×•×¦×“×•×¨×” ×‘×” ×ª×”×œ×™×š ×”×—×™×©×•×‘ ×”×•× ××™×˜×¨×˜×™×‘×™: 
 
```typescript
; Signature: gcd(n, m)
; Type: [Number * Number -> Number]
; Purpose: Returns the greatest common divider of n and m.
(define gcd
  (lambda (n m)
    (if (zero? m)
        n
        (gcd m (modulo n m)))))

```
×›×ª×™×‘×ª ×’×¨×¡×ª ×”-CPS ×”×™× ×ž×™×“×™×ª: ×”-continuation ×™×•×›×œ ×œ×”×™×©××¨ id (×›×œ×•×ž×¨ ×œ×œ× ×©×™× ×•×™) ×œ××•×¨×š ×›×œ ×”×—×™×©×•×‘. ×–××ª, ×›×™×•×•×Ÿ ×©-n ×ž×©×ž×© ×›-"×¦×•×‘×¨" ×œ×ª×©×•×‘×” ×‘×ž×§×¨×” ×–×”. × ×‘×—×™×Ÿ ×›×™ ×œ×ž×¢×©×” ××™× × ×• ×ž×¨×—×™×‘×™× ××ª ×”×¤×•× ×§×¦×™×” "×”× ×©×œ×—×ª" ×› - continuation ×‘×ž×”×œ×š ×¨×™×¦×ª \$gcd:

```typescript
; Signature: gcd$(n, m)
; Type: [Number*Number*[Number->T1] -> T1]
; Purpose: Returns the application of the continuation
;          c on the greatest common divider of n and m.
(define gcd$
  (lambda (n m c)
    (if (zero? m)
        (c n)
        (gcd$ m (modulo n m) c))))

> (gcd$ 6 9 sqr)
9

```

## ×©××œ×” 4 â€“ ×’×¨×¡×ª CPS ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×” ×œ×—×™×©×•×‘ ××•×¨×š ×¨×©×™×ž×”

× ×‘×—×Ÿ ×ª×—×™×œ×” ××ª ×”×ž×™×ž×•×© ×©×œ length, ×”×ž×—×©×‘×ª ××ª ××•×¨×›×” ×©×œ ×¨×©×™×ž×”:

```typescript
; Signature: length(lst)
; Type: [List -> Number]
; Purpose: Returns the length of the list lst.
(define length
  (lambda (lst)
    (if (empty? lst)
        0
        (+ 1 (length (cdr lst))))))

> (length '(a b c d))
4

```

×•×‘×’×¨×¡×ª CPS:

```typescript
; Signature: length$(lst, c)
; Type: [List*[Number->T1] -> T1]
; Purpose: Returns the application of the continuation
;          c on the length of the list lst.
(define length$
  (lambda (lst c)
    (if (empty? lst)
        (c 0)
        (length$ (cdr lst) 
                 (lambda (cdr-length) 
                   (c (+ cdr-length 1)))))))

> (length$ '(a b c d) id)
4

```
×”×¨×¢×™×•×Ÿ ×”×•× ×œ×”× ×™×— ×›×™ ××œ ×”×ž×©×ª× ×” cdr-length "×™×•×›× ×¡" ×”××•×¨×š ×©×œ ×–× ×‘ ×”×¨×©×™×ž×” (×–××ª ×›×™×•×•×Ÿ ×©×§×¨×× ×• ×¨×§×•×¨×¡×™×‘×™×ª ×œ×¤×•× ×§×¦×™×” \$length ×¢× (cdr lst)). ×›×œ×•×ž×¨ ×× ×• ×ž× ×™×—×™× ×›×™ cdr-length ×—×•×©×‘ ×•×›×œ ×©× ×•×ª×¨ ×”×•× ×œ×”×¤×¢×™×œ ××ª ×”-continuation ×¢×œ ×”×ª×•×¦××” ×©×”×™× ××•×¨×š ×”×¨×©×™×ž×” ×›×•×œ×” (××•×¨×š ×–× ×‘ ×”×¨×©×™×ž×” + 1). × ×‘×—×™×Ÿ ×›×™ ×‘×›×œ ×©×œ×‘ ×‘××™×˜×¨×¦×™×” × ×•×¦×¨×ª ×¤×•× ×§×¦×™×™×ª continuation ×—×“×©×” (×ž×•×¨×—×‘×ª) ×¤×¨×˜ ×œ×©×œ×‘ ×”××—×¨×•×Ÿ (×ž×§×¨×” ×”×‘×¡×™×¡). 

× ×©×™× ×œ×‘: ×”×©×™×ž×•×© ×‘-CPS ××™× ×• ×—×•×¡×š ×‘××•×¤×Ÿ ×›×œ×œ×™ ××ª ×”×–×™×›×¨×•×Ÿ ×”× ×“×¨×©, ××œ× ×¨×§ ×—×•×¡×š ××ª ×”×©×™×ž×•×© ×‘×ž×§×•× ×¢×œ ×”×ž×—×¡× ×™×ª. ×œ×ž×¢×©×”, ×”×¢×‘×¨× ×• ××ª ×”×©×™×ž×•×© ×‘×–×™×›×¨×•×Ÿ ×‘×›×œ ××™×˜×¨×¦×™×” ×ž×Ÿ ×”×ž×—×¡× ×™×ª ××œ ×”-heap (×”-continuations ×”× closures ×•×”× ×ž×™×•×¦×¨×™× ×¢×œ ×”-heap). 

## ×©××œ×” 5 â€“ ×’×¨×¡×ª CPS ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×•×ª ×ž×¡×“×¨ ×’×‘×•×” (\$\$map)

```typescript
; Signature: map(f, lst)
; Type: [[T1->T2] * List(T1) -> List(T2)]
; Purpose: Returns the list that results of applying
;          f to the members of lst.
; Example: (map - '(1 2 3 4 5)) => '(-1 -2 -3 -4 -5)
(define map
  (lambda (f lst)
    (if (empty? lst)
        lst
        (cons (f (car lst)) (map f (cdr lst))))))

```

×× ×× ×• ×ž× ×™×—×™× ×›×™ ×¤×¨×•×¦×“×•×¨×•×ª ×”×ž×™×¤×•×™ f ×”×ž×ª×§×‘×œ×ª ×›××¨×’×•×ž× ×˜ ×”×™× ×¤×¨×™×ž×™×˜×™×‘×™×ª (×•××™× ×” ×›×ª×•×‘×” ×‘×¦×•×¨×ª CPS):

```typescript
; Signature: map$(f, lst, c)
; Type: [ [T1->T2] * List(T1) * [List(T2)->T3] -> T3 ]
; Purpose: Returns the application of the continuation c on the list
;          that results of applying f to all the members of lst.
(define map$
  (lambda (f lst c)
    (if (empty? lst)
        (c lst)
        (map$ f (cdr lst)
              (lambda (mapped-cdr)
                (c (cons (f (car lst)) mapped-cdr)))))))

> (map$ - '(1 2 3 4 5) reverse)
'(-5 -4 -3 -2 -1)

```

×›×™×•×•×Ÿ ×©×”×¤×¨×•×¦×“×•×¨×” f ××™× ×” ×›×ª×•×‘×” ×‘×’×¨×¡×ª CPS, ×”×¤×¢×œ× ×• ××ª c ×¢×œ (cons (f (car lst)) mapped-cdr). ×›×¢×ª, × × ×™×— ×›×™ f ××™× ×” ×¤×¨×™×ž×™×˜×™×‘×™×ª, ×•×œ×›×Ÿ ×”×•×ž×¨×” ×œ×’×¨×¡×ª ×” CPS ×©×œ×”, \$f. × ×¨××” ×›×™×¦×“ ×œ×›×ª×•×‘ ××ª ×’×¨×¡×ª ×”-CPS  ×©×œ map, ×›××©×¨ ×”×¤×¨×•×¦×“×•×¨×” ××•×ª×” ×ž×¤×¢×™×œ×™× ×¢×œ ×›×œ ××—×“ ×ž××™×‘×¨×™ ×”×¨×©×™×ž×”, \$f, × ×ª×•× ×” ×‘×¢×¦×ž×” ×‘×’×¨×¡×ª CPS:
 
```typescript
; Signature: map$$(f$, lst, c)
; Type: [ [T1 * [T2->T3] -> T3] * List(T1) * [List(T3)->T4] -> T4 ]
; Purpose: Returns the application of the continuation c on 
;          the list that results of applying f to all the 
;          members of lst from the end to the start
(define map$$
  (lambda (f$ lst c)
    (if (empty? lst)
        (c lst)
        (map$$ f$ 
               (cdr lst) 
               (lambda (mapped-cdr)
                 (f$ (car lst)
                     (lambda (mapped-car)
                       (c (cons mapped-car mapped-cdr)))))))))

> (map$$ sqr$ '(1 2 3 4 5) id)
'(1 4 9 16 25)

``` 

× ×ª×‘×•× ×Ÿ ×‘-continuation ×©× ×‘× ×” ×œ××•×¨×š ×”×—×™×©×•×‘:


 ![diagram](./resources/ps10/diagram.png)       

 	
×”×¤×¨×•×¦×“×•×¨×” \$\$map ×ž×¤×¢×™×œ×” ××ª \$f ×¢×œ ××‘×¨×™ ×”×¨×©×™×ž×” ×ž×”×¡×•×£ ×œ×”×ª×—×œ×” (×‘×“×•×’×ž×” 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1).  ×”×¤×¢×œ×ª f ×•×”×§×¨×™××” ×œ-map ××™× ×Ÿ ×ª×œ×•×™×•×ª (××™× ×Ÿ ×ž×§×•× × ×•×ª ×–×• ×‘×–×•) ×•×œ×›×Ÿ × ×™×ª×Ÿ ×œ×‘×—×•×¨ ×ž×” ×™×ª×¨×—×© ×§×•×“× ×‘×’×¨×¡×ª ×” CPS. ×›×š × ×§×‘×¢ ××ª ×”×¡×“×¨ ×‘×• ×ª×•×¤×¢×œ \$f ×¢×œ ××‘×¨×™ ×”×¨×©×™×ž×” (×ž×”×”×ª×—×œ×” ×œ×¡×•×£ ××• ×œ×”×™×¤×š). ×”×’×¨×¡×” ×”×‘××” ×ž×¤×¢×™×œ×” ××ª \$f ×¢×œ ××‘×¨×™ ×”×¨×©×™×ž×” ×œ×¤×™ ×”×¡×“×¨ ×”×¨×’×™×œ ×©×œ ×ž×”×”×ª×—×œ×” ×œ×¡×•×£:

 ```typescript
(define map$$
  (lambda (f$ lst c)
    (if (empty? lst)
        (c lst)
        (map$$ f$ 
               (car lst) 
               (lambda (mapped-cdr)
                 (f$ (cdr lst)
                     (lambda (mapped-car)
                       (c (cons mapped-car mapped-cdr)))))))))

> (map$$ sqr$ '(1 2 3 4 5) id)
'(1 4 9 16 25)

```

<link rel='stylesheet' type='text/css' href='resources/ps10/style.css' media='all'/>
