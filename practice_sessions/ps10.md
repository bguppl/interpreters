<h1><b>Lazy-Lists and Continuation Passing Style (CPS)</b></h1>

<h2><b>Practical Session - Week #10</b></h2>

## Lists-Lazy

×ª×–×›×•×¨×ª: ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª ×”×Ÿ ×ž×‘× ×™ × ×ª×•× ×™× ×¡×“×¨×ª×™×™× ×”×ž××¤×©×¨×™× ×“×—×™×™×” ×©×œ ×—×™×©×•×‘ ×•×©×ž×™×¨×” ×©×œ ××™×‘×¨×™× ×ž×ª×•×›×.
×”×™×ª×¨×•× ×•×ª ×‘×©×™×ž×•×© ×‘×”×Ÿ:
* ××™×Ÿ ×¦×•×¨×š ×œ××—×¡×Ÿ ×‘×–×™×›×¨×•×Ÿ ××ª ×›×œ ××™×‘×¨×™ ×”×¨×©×™×ž×”. ×‘×¢×–×¨×ª ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª × ×™×ª×Ÿ ×œ×™×™×¦×’ ××£ ×¡×“×¨×•×ª ××™× ×¡×•×¤×™×•×ª.
* ×“×—×™×™×ª ×—×™×©×•×‘ ××™×‘×¨×™× ×‘×¨×©×™×ž×” ×œ×–×ž×Ÿ ×‘×• × ×“×§×§ ×œ×”× â€“ ×™×™×ª×›×Ÿ ×©×œ× × ×–×“×§×§ ×œ×›×œ ××™×‘×¨×™ ×”×¨×©×™×ž×”.

× ×’×“×™×¨ ××ª ×¢×¨×›×™ ×”×˜×™×¤×•×¡ ×©×œ ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª ×‘××•×¤×Ÿ ×¨×§×•×¨×¡×™×‘×™:

```typescript
LzL = { empty-lzl } âˆª (Scheme-Type Ã— [Empty â†’ LzL])
```
×–×”×• ADT ×¢×‘×•×¨ ×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª (×”×ž×™×ž×•×© ×ž×•×¤×™×¢ ×‘×¡×¤×¨ ×”×§×•×¨×¡):

```typescript
; Signature: cons-lzl(x, lzl)
; Type: [T * LzL -> LzL]

; Signature: head(lz-list)
; Type: [LzL -> T]
; Pre-condition: non-empty LzL

; Signature: tail(lz-list)
; Type: [LzL -> LzL]
; Pre-condition: non-empty LzL

; Signature: empty-lzl?(exp)
; Type: [T -> Boolean]

; Signature: nth(lz-list, n)
; Type: [LzL * Number -> T]

; Signature: take(lz-list, n)
; Type: [LzL * Number -> List]
```

#### ×©××œ×” 1 â€“ ×”×©×¢×¨×ª ×§×•×œ×¥
× ×’×“×™×¨ ××ª ×”×¤×•× ×§×¦×™×”:
![collatz](https://github.com/bguppl/interpreters/blob/gh-pages/practice_sessions/collatz%20conjecture.png)
× ×¨×¦×” ×œ×”×’×“×™×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×”×ž×›×™×œ×” ××ª ×¡×“×¨×ª ×§×•×œ×¥ ×¢×‘×•×¨ n ×›×œ×©×”×•.

```typescript
; Signature: lzl-collatz(n)
; Type: [Number -> LzL(Number)]
; Purpose: Generate the (possibly infinite) series { n, f(n), f(f(n)), ... },
; where f(n) is collatz function
; Pre-condition: n is a natural number greater than zero
(define lzl-collatz
 (lambda (n)
 (if (< n 2)
 (cons-lzl n (lambda () empty-lzl))
 (cons-lzl n
 (lambda ()
 (if (= (modulo n 2) 0)
 (lzl-collatz (/ n 2))
 (lzl-collatz (+ (* 3 n) 1))))))))
> (take (lzl-collatz 563) 44)
'(563 1690 845 2536 1268 634 317 952 476 238 119 358 179 538 269 808 404 202
101 304 152 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1)
```
×ž×” ×”×˜×™×¤×•×¡ ×©×œ collatz-lzl ?×”×× ×”×¤×¨×•×¦×“×•×¨×” ×”×™× typed-well ?×”×× ((n collatz-lzl (head (×¢×‘×•×¨ n ×˜×‘×¢×™ ×›×œ×©×”×™ ×ª×ž×™×“
×ª×¦×œ×™×—?

×©××œ×” 2 â€“ ×¡×“×¨×ª ×”×”×¤×¢×œ×•×ª ×”×¢×¦×ž×™×•×ª
×‘×”×™× ×ª×Ÿ ×¤×•× ×§×¦×™×” ï¿½ï¿½ ×•×¢×¨×š ï¿½ï¿½, × ×’×“×™×¨ ××ª ×¡×“×¨×ª ×”×”×¨×›×‘×•×ª ×”×¢×¦×ž×™×•×ª ×œ×”×™×•×ª { ... , (((ï¿½ï¿½)ï¿½ï¿½)ï¿½ï¿½) ï¿½ï¿½ ,((ï¿½ï¿½)ï¿½ï¿½)ï¿½ï¿½ ,(ï¿½ï¿½)ï¿½ï¿½ ,ï¿½ï¿½}. ×”×¡×“×¨×”
×™×›×•×œ×” ×œ×”×™×•×ª ×¡×•×¤×™×ª, ××• ××™× ×¡×•×¤×™×ª. × ×¨×¦×” ×œ×™×™×¦×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×©××™×‘×¨×™×” ×”× ××™×‘×¨×™ ×”×¡×“×¨×”. ×”×¨×©×™×ž×” ×ª×™×’×ž×¨ ×›××©×¨
×”×’×™×¢×” ×œ× ×§×•×“×ª ×©×‘×ª, ×›×œ×•×ž×¨ ×›××©×¨ ×”×¢×¨×š ×”×ž×•×—×–×¨ ×ž×”×¤×¢×œ×ª ï¿½ï¿½ ×”×•× ××•×ª×• ×”×¢×¨×š ×©×¢×œ×™×• ï¿½ï¿½ ×”×•×¤×¢×œ×”.
; Signature: lzl-apply(f, x)
; Type: [[T -> T] * T -> LzL]
; Purpose: Generate the self-application series of f on x
(define lzl-apply
 (lambda (f x)
 (let ((fx (f x)))
 (if (= fx x)
 empty-lzl
 (cons-lzl x (lambda () (lzl-apply f fx)))))))
> (take (lzl-apply (lambda (x) (+ 1 (/ 1 x))) 1.0) 100)
'(1.0 2.0 1.5 1.6666666666666665 1.6 1.625 ... 1.6180339887498951)
> (take (lzl-apply (lambda (x) x) 1) 100)
'()
ð‘™ð‘’ð‘›ð‘”ð‘¡â„Ž = 38
Continuation Passing Style (CPS) â€“ '×‘ ×—×œ×§

e Passing Continuation :×¤×¨×“×™×’×ž×” ×ª×›× ×•×ª×™×ª ×‘×” ×œ×›×œ ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© × ×™×ª×Ÿ ×¤×¨×ž×˜×¨ × ×•×¡×£ ×©×”×™× ×• ×¤×¨×•×¦×“×•×¨×”, ××©×¨
×ž×”×•×•×” ××ª ×”×ž×©×š ×”×—×™×©×•×‘ ×©×™×© ×œ×‘×¦×¢ ×‘×ª×•× ×¤×¢×•×œ×ª ×¤×¨×•×¦×“×•×¨×ª ×”×ž×©×ª×ž×© )×•×¢×œ ×›×Ÿ × ×§×¨× ×”×¤×¨×ž×˜×¨ continuation .)×—×œ×§ ×ž×Ÿ
×”×ž×•×˜×™×‘×¦×™×” ×œ×©×™×ž×•×© ×‘×¤×¨×“×™×’×ž×ª ×ª×›× ×•×ª ×–×• ×”×™× ×”×©×œ×™×˜×” ×©×”×™× ×ž××¤×©×¨×ª ×‘×‘×§×¨×” ×©×œ ×”×ª×•×›× ×™×ª:
1 .×‘×ž×”×œ×š ×›×ª×™×‘×ª ×¤×¨×•×¦×“×•×¨×•×ª ×ž×©×ª×ž×© ×‘×©×™×˜×ª CPS ,×›×œ ×§×¨×™××” ×¨×§×•×¨×¡×™×‘×™×ª × ×›×ª×‘×ª ×›×š ×©×”×™× ×‘×¢×ž×“×ª ×–× ×‘. ×œ×›×Ÿ, ×ž×¢×¦×
×”×©×™×ž×•×© ×‘×©×™×˜×”, ×”×¤×¨×•×¦×“×•×¨×” ×ª×™×™×¦×¨ ×ª×”×œ×™×š ××™×˜×¨×˜×™×‘×™.
2 .CPS ×ž××¤×©×¨ ×œ×©×œ×•×˜ ×‘×¡×“×¨ ×œ×¤×™×• ×”×ª×•×›× ×™×ª ×ª×—×©×‘ ×‘×™×˜×•×™×™×. ×œ×ž×©×œ, ×× × ×ž×ž×© ×—×™×¤×•×© ×‘×¢×¥, × ×•×›×œ ×œ×‘×—×•×¨ ×× ×œ×—×¤×© ×§×•×“×
×‘×¢× ×£ ×”×™×ž× ×™ ××• ×‘×©×ž××œ×™ )×œ×¢×•×ž×ª ×–××ª, ×œ×œ× CPS × ×”×™×™×” ×ª×œ×•×™×™× ×‘×¡×“×¨ ×”×¢×¨×›×ª ×”×‘×™×˜×•×™×™× ×”×ž×•×‘× ×” ×‘-interpreter.)
3 .×”×©×œ×™×˜×” ×‘×‘×§×¨×ª ×”×ª×•×›× ×™×ª ×ž××¤×©×¨×ª ×œ× ×§×•×˜ ×‘×¤×¢×•×œ×” ×©×•× ×” ×‘×ž×§×¨×” ×©×œ ×”×¦×œ×—×” / ×›×™×©×œ×•×Ÿ ××• ×™×¦×™××” ×™×©×™×¨×” )exception )
×‘×ž×”×œ×š ×¨×§×•×¨×¡×™×” )××• ××™×˜×¨×¦×™×”( ×•×›×Ÿ ×ž××¤×©×¨×ª ×œ×”×—×–×™×¨ ×›×ž×” ×¢×¨×›×™× ×‘×™×—×“.
×©××œ×” 1 â€“ ××•×¤×Ÿ ×¤×¢×•×œ×ª ×¤×¨×•×¦×“×•×¨×” ×‘×’×¨×¡×ª CPS ×•×”×•×›×—×ª × ×›×•× ×•×ª
× ×™×–×›×¨ ×‘×ž×™×ž×•×© ×©×œ ×”×¤×¨×•×¦×“×•×¨×” fact ×œ×œ× ×©×™×ž×•×© ×‘-CPS:
```typescript
; Type: [Number -> Number]
; Purpose: To calculate the factorial of n.
(define fact
 (lambda (n)
 (if (= n 0)
 1
 (* n (fact (- n 1))))))
```
×›×¢×ª, × ×ž×ž×© ××ª fact ×‘×©×™×˜×ª CPS ×•× ×ž×—×™×© ××ª ××•×¤×Ÿ ×”×¤×¢×•×œ×” ×©×œ×”:
```typescript
; Type: [Number * [Number->T1] -> T1]
; Purpose: Returns the application of the
; continuation c on the factorial of n.
(define fact$
 (lambda (n c)
 (if (= n 0)
 (c 1)
 (fact$ (- n 1)
 (lambda (fact_n-1)
 (c (* n fact_n-1)))))))
> (fact 5)
120
> (fact$ 5 add1)
121
```
×“×™×•×Ÿ: ×ž×“×•×¢ ×”×ª×•×¦××•×ª ××™× ×Ÿ ×–×”×•×ª? ×›×™×¦×“ × ×¨×¦×” ×œ×§×‘×•×¢ ×‘×“×¨×š ×›×œ×œ ××ª ×¤×¨×•×¦×“×•×¨×ª ×”-continuation ×©× ×¢×‘×™×¨ ×œ×§×¨×™××” ×”×¨××©×•× ×”?

×”×•×›×—×ª × ×›×•× ×•×ª: ×œ××—×¨ ×”×ž×¨×ª ×¤×¨×•×¦×“×•×¨×” ×œ×’×¨×¡×ª ×”-CPS ×©×œ×”, × ×“×¨×©×ª ×”×•×›×—×ª × ×›×•× ×•×ª. ×”× ×›×•× ×•×ª × ×©×¢× ×ª ×¢×œ ×”×¦×’×ª ×©×§×™×œ×•×ª ×‘×™×Ÿ
×©×ª×™ ×”×’×¨×¡××•×ª, ×‘×ž×•×‘×Ÿ ×”×‘×: ×‘×”×¤×¢×œ×ª ×”××œ×’×•×¨×™×ª× eval-applicative ×¢×œ ×§×¨×™××” ×ž×ª××™×ž×” ×œ×›×œ ××—×ª ×ž×Ÿ ×”×’×¨×¡××•×ª,
×”×—×™×©×•×‘ ×™×¡×ª×™×™× ×•×™×•×—×–×¨ ×¢×¨×š ×–×”×”. ×œ×©× ×›×š, × ×–×“×§×§ ×œ×”×’×“×¨×ª ×”×©×§×™×œ×•×ª ×”×‘××”:
×”×’×“×¨×”: ×¤×¨×•×¦×“×•×¨×” $f ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” f ×× ×œ×›×œ ×¢×¨×›×™ ×§×œ×˜ x3,â€¦,x2,x1 ×•×œ×›×œ continuation ×”×ž×¡×•×ž×Ÿ cont ,
×ž×ª×§×™×™×:
(f$ x1 â€¦ xn cont) = (cont (f x1 â€¦ xn))
×˜×¢× ×”: ×”×¤×¨×•×¦×“×•×¨×” $fact ×©×§×•×œ×”-CPS ×œ×¤×¨×•×¦×“×•×¨×” fact .×›×œ×•×ž×¨, ×œ×›×œ ×ž×¡×¤×¨ ×˜×‘×¢×™, n ,×•×œ×›×œ continuation ,××©×¨ ×™×¡×•×ž×Ÿ
(fact$ n c) = (c (fact n))
×¢×œ ×™×“×™ c ,×ž×ª×§×™×™×:
×”×•×›×—×”: ×›×™×•×•×Ÿ ×©×”×¤×¨×•×¦×“×•×¨×” fact ×”×™× ×¨×§×•×¨×¡×™×‘×™×ª, ×”×”×•×›×—×” ×ž×ª×‘×¦×¢×ª ×¢×œ ×™×“×™ ×©×™×ž×•×© ×‘××™× ×“×•×§×¦×™×”.
×‘×¡×™×¡ ×”××™× ×“×•×§×¦×™×”: 0ð‘› =
a-e[ (fact$ 0 c) ] ==>* a-e[ (c 1) ] = a-e[ (c (fact 0)) ]
×”× ×—×ª ×”××™× ×“×•×§×¦×™×”: ×¢×‘×•×¨ â„• ð‘› = ð‘˜ âˆˆ ×”×˜×¢× ×” ×ž×ª×§×™×™×ž×ª ×œ×›×œ ï¿½ï¿½ â‰¤ ï¿½ï¿½. ×›×œ×•×ž×¨
(fact$ i c) = (c (fact i))
×¦×¢×“ ×”××™× ×“×•×§×¦×™×”: ×™×”× â„•, ð‘˜ âˆˆ 1 ,ð‘› = ð‘˜ + ××–×™:
a-e [ (fact$ n c) ] ==>*
a-e [ (fact$ (- n 1) (lambda (res) (c (* n res)))) ] ==>*
×ž×”× ×—×ª ×”××™× ×“×•×§×¦×™×”, × ×§×‘×œ:
a-e [ ((lambda (res) (c (* n res))) (fact (- n 1))) ] ==>*
a-e [ (c (* n (fact (- n 1)))) ] =
a-e [ (c (fact n)) ]
×›×œ×œ×™ ××¦×‘×¢ ×œ×”×ž×¨×ª ×¤×¨×•×¦×“×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª ×œ×¤×¨×•×¦×“×•×¨×” ×©×§×•×œ×”-CPS:
×‘×”×™× ×ª×Ÿ ×¤×¨×•×¦×“×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª, f ,×¢× ×”×¤×¨×ž×˜×¨×™× ×”×¤×•×¨×ž××œ×™×™× xn,â€¦,x1 ,×¤×¨×•×¦×“×•×¨×” ×©×§×•×œ×”-CPS ×œ×” ×ª×¡×•×ž×Ÿ $f ×•×ª×•×¤×¢×œ
×¢×œ ××¨×’×•×ž× ×˜ × ×•×¡×£, c ,×”-continuation .×”×¢×§×¨×•× ×•×ª ×©×™× ×—×• ××•×ª× ×• ×‘×›×ª×™×‘×ª $f ×”× ×›×“×œ×§×ž×Ÿ:
×. × ×¤×¢×™×œ ××ª c ×¢×œ ×¢×¨×›×™× ×ž×•×—×–×¨×™× )×›×—×œ×§ ×ž×ž×§×¨×” ×”×‘×¡×™×¡, ××• ×‘×ª×•×š continuation ×”× ×•×¦×¨ ×‘×ž×”×œ×š ×”×¨×™×¦×”(.
×‘. × ×§×¤×™×“ ×œ×›×ª×•×‘ ×›×œ ×§×¨×™××” ×œ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© ×‘×ª×•×š $f ×›×š ×©×”×§×¨×™××” ×ª×”×™×” ×‘×¢×ž×“×ª ×–× ×‘.
×’. ×›×ª×™×‘×ª ×”-continuation:
a .×›×©× ×‘×¦×¢ ×‘×ª×•×š $f ×§×¨×™××” ×¨×§×•×¨×¡×™×‘×™×ª ×›×œ×©×”×™ ×¢× ××¨×’×•×ž× ×˜×™× xn,â€¦,x1 ,× ×ª×‘×¡×¡ ×¢×œ ×”× ×—×ª ×”××™× ×“×•×§×¦×™×”
)×”×ž×§×˜×™× ×” ××ª ×”×‘×¢×™×”(. ×›×œ×•×ž×¨, × × ×™×— ×›×™ ×”×ª×©×•×‘×” ×¢×‘×•×¨ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª ×ž×ª×§×‘×œ×ª ×›××¨×’×•×ž× ×˜ ×©×œ
×”-continuation.
b .×‘×›×ª×™×‘×ª ×”-continuation ,× ×§×™×™× ××ª ×¦×¢×“ ×”××™× ×“×•×§×¦×™×” ×•× ×¤×¢×œ ×¢×œ ×”×¤×ª×¨×•×Ÿ ×¢×‘×•×¨ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª
×›×“×™ ×œ×§×‘×œ ××ª ×”×¤×ª×¨×•×Ÿ ×œ×‘×¢×™×” ×”×’×“×•×œ×” ×™×•×ª×¨.
×“. ×‘×›×ª×™×‘×ª ×¤×¨×•×¦×“×•×¨×” ×‘×©×™×˜×ª CPS ,× ×§×¤×™×“ ×©×›×œ ×¤×¨×•×¦×“×•×¨×ª ×ž×©×ª×ž×© )×œ× ×¤×¨×™×ž×™×˜×™×‘×™×ª( ×”×ž×©×ž×©×ª ××ª $f ×ª×”×™×” ×’× ×”×™×
×›×ª×•×‘×” ×‘×©×™×˜×ª CPS.
×”. ×‘×“×¨×š ×›×œ×œ, ×œ× × ×¨×¦×” ×œ×‘×¦×¢ ×ž× ×™×¤×•×œ×¦×™×” ×¢×œ ×”×¢×¨×š ×”×ž×•×—×–×¨ ×©×œ ×”×¤×•× ×§×¦×™×” ×•×œ×›×Ÿ × ×©×ª×ž×© ×‘×¤×•× ×§×¦×™×™×ª ×”×–×”×•×ª id
×›-continuation ×”×”×ª×—×œ×ª×™.
6
×©××œ×” 2 â€“ ×¤×•× ×§×¦×™×•×ª CPS ×ž×¡×“×¨ ×’×‘×•×”
× ×ž×™×¨ ××ª ×”×¤×•× ×§×¦×™×” foldr ×œ-CPS .×ª×–×›×•×¨×ª:
(foldr op initial (list x1 x2 ... xn))
â‡•
(op x1 (op x2 (op ... (op xn initial))))
; Signature: foldr(op, initial, sequence)
; Type: [ [ T1 * T2 -> T2 ] * T2 * List(T1) -> T2 ]
; Example: (foldr + 0 (list 1 2 3 4 5)) => 15
(define foldr
 (lambda (op initial sequence)
 (if (empty? sequence)
 initial
 (op (car sequence)
 (foldr op initial (cdr sequence))))))
; Signature: foldr$(op, initial, sequence, c)
; Type: [ [T1 * T2 -> T2] * T2 * List(T1) * [T2 -> T3] -> T3 ]
; Example: (foldr$ * 1 (list 1 2 3 4 5)
; (lambda (result) (cons 'the-product result)))
; => '(the-product . 120)
(define foldr$
 (lambda (op initial sequence c)
 (if (empty? sequence)
 (c initial)
 (foldr$ op
 initial
 (cdr sequence)
 (lambda (acc-cdr-res)
 (c (op (car sequence) acc-cdr-res)))))))
; Signature: foldr$$(op$, initial, sequence, c)
; Type: [ [T1 * T2 * [T2->T3] -> T3] * T2 * List(T1) * [T2->T3] -> T3 ]
; Example: (foldr$ +$ 0 (list 1 2 3 4 5)
; (lambda (result) (cons 'the-sum result)))
; => '(the-sum . 15)
(define foldr$$
 (lambda (op$ initial sequence c)
 (if (empty? sequence)
 (c initial)
 (foldr$$ op$
 initial
 (cdr sequence)
 (lambda (acc-cdr-res)
 (op$ (car sequence) acc-cdr-res c))))))
× ×©×™× ×œ×‘: ×ž×“×•×¢ ×œ× ×™×›×•×œ× ×• ×œ×”×¤×¢×™×œ ××ª c ×¢×œ ×ª×•×¦××ª $op ×‘×ž×§×•× ×œ×”×¢×‘×™×¨ ×œ×” ××ª c ×›××¨×’×•×ž× ×˜? ×¨××©×™×ª, ×œ×• ×¢×©×™× ×• ×›×š,
×”×§×¨×™××” ×œ× ×”×™×™×ª×” ×‘×¢×ž×“×ª ×–× ×‘. ×‘× ×•×¡×£, ×”×‘×¢×™×” ×”×ž×”×•×ª×™×ª ×™×•×ª×¨ ×”×™× ×©×‘×ž×§×¨×” ×›×–×” ×”×™×™× ×• ×ž××‘×“×™× ××ª ×”×©×œ×™×˜×” ×¢×œ ×ª×”×œ×™×š
×”×—×™×©×•×‘ ×”×ž×’×•×œ×ž×ª ×‘×ª×•×š ×”-continuation .
7
×©××œ×”4 â€“ ×¢×¦×™×¨×ª ×”×—×™×©×•×‘
×”×¤×•× ×§×¦×™×” $list-mul ×ž×§×‘×œ×ª ×¨×©×™×ž×” ×©×œ ×¨×©×™×ž×•×ª ×•×ž×—×–×™×¨×” ×ž×›×¤×œ×” ×©×œ ×›×œ ×”×ž×¡×¤×¨×™× ×‘×¨×©×™×ž×”. ×× ×™×© ×ž×•×¤×¢ ××˜×•×ž×™
×©××™× ×• ×ž×¡×¤×¨ ××– ×™×© ×œ×¢×¦×•×¨ ××ª ×”×—×™×©×•×‘.
; Signature: mul-list$(ls, succ, fail)
; Type:[List*[Number->T1]*[Empty->T2]-> T1 Union T2]
; Examples: (mul-list$ (list 1 2 (list 3 4 5) (list 6 7 10))
; id
; (lambda() 'not-a-number))
; => 50400
;
; (mul-list$ (list 1 2 (list 3 'a 5) (list 6 7 10))
; id
; (lambda() 'not-a-number))
; => 'not-a-number
(define mul-list$
 (lambda (ls succ fail)
 (cond ((empty?? ls) (succ 1))
 ((not (pair? ls)) (if (number? ls)
 (succ ls)
 (fail)))
 (else (mul-list$ (car ls)
 (lambda (mul-car)
 (mul-list$ (cdr ls)
 (lambda (mul-cdr)
 (succ (* mul-car mul-cdr)))
 fail))
 fail)))))
8
×©××œ×” 4 â€“ ×©×™×ž×•×© ×‘×ž×¡×¤×¨ continuations
×œ×¦×•×¨×š ×”×¤×©×˜×ª ×”×¢×‘×•×“×” ×ž×•×œ ×¨×©×™×ž×•×ª, × ×©×ª×ž×© ×‘-ADT ×¢×‘×•×¨ ×¢×¦×™× )×”×ž×™×ž×•×© ×ž×•×¤×™×¢ ×‘×¡×¤×¨ ×”×§×•×¨×¡(. ×›×¤×™ ×©×›×‘×¨ ×¨××™× ×• ×‘×¢×‘×¨ ×¢×‘×•×¨
×¨×©×™×ž×•×ª ×•×¨×©×™×ž×•×ª ×¢×¦×œ×•×ª, ×’× ×¢×¥ ×ž×•×’×“×¨ ×‘×¦×•×¨×” ×¨×§×•×¨×¡×™×‘×™×ª:
×¢×¥ ×”×•× Empty-Tree .1
×¢×¥ ×”×•×) add-subtree (make-leaf e) t) ×©×œ ×”×¢×¨×š: e ×œ×›×œ ××–×™, ×¢×¥ t ××. 2
×ž×ž×©×§ ×”-ADT:
; Signature: make-tree(1st, ..., nth)
; Type: [Tree * ... * Tree -> Tree]
; Signature: add-subtree(subtree, tree)
; Type: [Tree * Tree -> Tree]
; Signature: make-leaf(data)
; Type: [T -> Tree]
; Signature: empty-tree
; Type: Empty-Tree
; Signature: first-subtree(tree)
; Type: [Tree -> Tree]
; Signature: rest-subtrees(tree)
; Type: [Tree -> Tree]
; Signature: leaf-data(leaf)
; Type: [Tree -> T]
; Signature: composite-tree?(e)
; Type: [T -> Boolean]
; Signature: leaf?(e)
; Type: [T -> Boolean]
; Signature: empty-tree?(e)
; Type: [T -> Boolean]
9
×”×¤×•× ×§×¦×™×” $leaves-replace ×ž×§×‘×œ×ª ×¢×¥ ×”×•×ž×•×’× ×™, ×¤×¨×“×™×§×˜ )×©××™× ×• ×›×ª×•×‘ ×‘×’×¨×¡×ª CPS ,)×¤×•× ×§×¦×™×” new ×©×ž×§×‘×œ×ª ××ª
×¢×¨×š ×”×¢×œ×” ×•×ž×—×–×™×¨×” ×¢×¨×š ×—×“×© ×¢×œ ×¤×™×• ×•×©× ×™ continuations :××—×“ ×¢×‘×•×¨ ×”×¦×œ×—×” ×•×”×©× ×™ ×¢×‘×•×¨ ×›×™×©×œ×•×Ÿ. ×”×ž×˜×¨×” ×”×™× ×œ×”×—×œ×™×£ ××ª
×›×œ ×”×¢×œ×™× ××©×¨ ×ž×§×™×™×ž×™× ××ª ×”×¤×¨×“×™×§×˜, ×‘×”×¤×¢×œ×” ×©×œ new ×¢×œ ×¢×¨×š ×”×¢×œ×”.
; Signature: replace-leaves$(tree, pred?, new, succ, fail)
; Type: [Tree(T) * [T->Boolean] * T * [Tree->T1] * [Empty->T2] -> T1 U T2]
(define replace-leaves$
 (lambda (tree pred? new succ fail)
 (cond ((empty-tree? tree) (fail))
 ((leaf? tree) (if (pred? (leaf-data tree))
 (succ (make-leaf (new (leaf-data tree))))
 (fail)))
 (else (replace-leaves$
 (first-subtree tree)
 pred?
 new
 (lambda (first-res)
 (replace-leaves$
 (rest-subtrees tree)
 pred?
new
(lambda (rest-res)
 (succ (add-subtree first-res rest-res)))
 (lambda ()
 (succ (add-subtree first-res (rest-subtrees tree))))))
 (lambda ()
 (replace-leaves$
 (rest-subtrees tree)
 pred?
new
(lambda (rest-res)
 (succ (add-subtree (first-subtree tree) rest-res)))
 fail)))))))
> (define tree (make-tree (make-tree (make-leaf 1) (make-leaf 2))
 (make-tree (make-leaf 3) (make-leaf 4)
 (make-tree (make-leaf 5)))))
> (replace-leaves$ tree even? (lambda(x)42) (lambda (x) x) (lambda () tree))
'((1 42) (3 42 (5)))
fail
success
f
s
s
×”×¢×¨×”: ×™×›×•×œ× ×• ×‘×ž×§×•× succ ×•-fail ×œ×”×¢×‘×™×¨ ×¤×¨×•×¦×“×•×¨×•×ª ×©×ž×‘×¦×¢×•×ª ×ž× ×™×¤×•×œ×¦×™×•×ª ××—×¨×•×ª ×¢×œ ×”×ª×•×¦××” â€“ ×›×œ ×–××ª ×ž×‘×œ×™ ×œ×©× ×•×ª
×©×•×¨×” ××—×ª ×‘×§×•×“ ×”×§×™×™× ×©×œ $leaves-replace .×œ×“×•×’×ž×”:
10
> (replace-leaves$ tree
 (lambda (x) (> x 100))
 (lambda(x)x)
 (lambda (x) x)
 (lambda ()
 (replace-leaves$ tree
odd?
(lambda(x)(+ 1 x))
(lambda(x)(rest-subtree x)
(lambda()'failled)
 )
)
'((4 4) (6)))
> (replace-leaves$ tree
 (lambda (x) (> x 100))
(lambda(x)(* 2 x))
 (lambda (x) x)
 (lambda ()
 (replace-leaves$ tree
zero?
(lambda(x)(+ 1 x))
(lambda(x)(rest-subtree x)
(lambda() (error "failled to replace anyting"))
 )
)
This raise exception
Error "failed to replace anything"
11
continuation â€“ 5 ×©××œ×”
×¤×¨×•×¦×“×•×¨×•×ª ×”-CPS ×©×× ×• ×™×•×¦×¨×™×, ×œ×ž×¢×©×” ××™× ×Ÿ ×‘×¢×¦×ž×Ÿ ×ž×—×©×‘×•×ª ××ª ×”×ª×•×¦××”, ××œ× ×ž×™×™×¦×¨×•×ª )×¢×œ ×™×“×™ ×™×¦×™×¨×ª continuations )
×¤×¨×•×¦×“×•×¨×” ×”×ž×”×•×•×” ××ª ×ª×”×œ×™×š ×”×—×™×©×•×‘. ×× × ×§×¤×™×“ ×œ×™×™×¦×¨ continuations ××©×¨ ×ž×§×‘×œ×™× ×ž×¡×¤×¨ ××¨×’×•×ž× ×˜×™× ×•×‘××•×¤×Ÿ ×¢×§×‘×™ × ×¤×¢×™×œ
××•×ª× ×¢×œ ××•×ª×• ×ž×¡×¤×¨ ×©×œ ××¨×’×•×ž× ×˜×™×, × ×•×›×œ ×œ×•×ž×¨ ×©×ª×”×œ×™×š ×”×—×™×©×•×‘ ×©× ×™×™×¦×¨ "×ž×—×–×™×¨" ×ž×¡×¤×¨ ×¢×¨×›×™×.
× ×¨××” ×œ×”×œ×Ÿ ×¤×¨×•×¦×“×•×¨×” ×‘×” ×ª×›×•× ×” ×–×• ×©×™×ž×•×©×™×ª. ×”×¤×¨×•×¦×“×•×¨×” ×ž×¤×¦×œ×ª ×¨×©×™×ž×” × ×ª×•× ×” ×œ×©×ª×™ ×¨×©×™×ž×•×ª ×œ×¤×™ ×¤×¨×“×™×§×˜ ×¤×¨×™×ž×™×˜×™×‘×™, pred .
×”-continuation ×ž×§×‘×œ ×©× ×™ ××¨×’×•×ž× ×˜×™×: ×¨×©×™×ž×ª ×”××™×‘×¨×™× ×ž×Ÿ ×”×‘×¢×™×” ×”×ž×•×§×˜× ×ª ××©×¨ ×§×™×™×ž×• ××ª ×”×¤×¨×“×™×§×˜ ×•×¨×©×™×ž×ª ××œ×• ×©×œ×.
×¢×œ ×©×ª×™ ×”×¨×©×™×ž×•×ª ×™×ª×‘×¦×¢ ×”×ž×©×š ×”×—×™×©×•×‘.
; Signature: split$(pred lst c)
; Type: [ [T1->Boolean] * List(T1) * [List(T1) * List(T1) -> T2] -> T2 ]
; Purpose: Returns the application of the continuation c on two lists:
; 1. A list of members for which the predicate holds.
; 2. A list of members for which it doesn't.
; Examples: (split$ even? '(1 2 3 4 5 6 7)
; (lambda (x y) (list x y)))
; => '((2 4 6) (1 3 5 7))
(define (split$ pred lst c)
 (if (empty? lst)
 (c lst lst)
 (split$ pred
 (cdr lst)
 (lambda (cdr-yes-list cdr-no-list)
 (if (pred (car lst))
 (c (cons (car lst) cdr-yes-list)
 cdr-no-list)
 (c cdr-yes-list
 (cons (car lst) cdr-no-list)))))))
> (split$ even?
 '(1 2 3 4 5)
 (lambda (evens odds) (- (foldr + 0 evens) (foldr + 0 odds))))
-3
12
×“×•×’×ž××•×ª × ×•×¡×¤×•×ª ×œ×¢×™×•×Ÿ
×©××œ×” 1" â€“ 7 ×‘×•×"
× ×™×™×¦×¨ ××ª ×”×¨×©×™×ž×” ×”×¢×¦×œ×” ×©××™×‘×¨×™×” ×ž×ª××™×ž×™× ×œ×—×•×§×™ ×”×ž×©×—×§ 7 ×‘×•×:
; Signature: has-digit(n)
; Type: [Number*Number->boolean]
; Pre-condition: n is a number d is a digit
(define has-digit
 (lambda(n d)
 (cond ((and(= n 0)(= d 0)) #t)
 ((= n 0)#f)
 (else (if (= d (modulo n 10))#t (has-digit (quotient n 10) d))))))
; Signature: sum-digits(n)
; Type: [Number->Number]
; Pre-condition: n is a number
(define sum-digits
(lambda(n)
(if (= n 0)0 (+(modulo n 10) (sum-digits (quotient n 10))))))
; Signature: seven-boom(n)
; Type: [Number -> LzL(Number)]
; Pre-condition: n is a natural number
(define seven-boom
 (lambda (n)
 (cons-lzl (cond ((= (modulo n 7) 0) 'boom)
 ((has-digit? n 7) 'boom)
 ((= (modulo (sum-digits n) 7) 0) 'boom)
 (else n))
 (lambda ()
 (seven-boom (+ n 1))))))
> (seven-boom 1)
'(1 . #<procedure>)
> (take (seven-boom 1) 7)
'(1 2 3 4 5 6 boom)
13
×©××œ×” 2 â€“ ×¨×§×•×¨×¡×™×” ×”×“×“×™×ª ×¢× CPS
; Signature: even?(n)
; Type: [Number -> Boolean]
; Purpose: Returns true if the number n is even, and false otherwise.
; Pre-condition: n >= 0
(define even?
 (lambda (n)
 (if (zero? n)
 #t
 (odd? (sub1 n)))))
; Signature: odd?(n)
; Type: [Number -> Boolean]
; Purpose: Returns true if the number n is odd, and false otherwise.
(define odd?
 (lambda (n)
 (if (zero? n)
 #f
 (even? (sub1 n)))))
> (even? 7)
#f
×›××©×¨ × ×¨×¦×” ×œ×”×ž×™×¨ ×¤×•× ×§×¦×™×•×ª ×¨×§×•×¨×¡×™×‘×™×•×ª ×”×“×“×™×•×ª ×œ-CPS ,× ×ž×™×¨ ××ª ×›×•×œ×Ÿ ×œ-CPS.
; Signature: even?$(n, c)
; Type: [Number * [Boolean->T1] -> T1]
; Purpose: Returns the application of the continuation c on true if the
; number n is even, and the application of
; c on false otherwise.
(define even?$
 (lambda (n c)
 (if (zero? n)
 (c #t)
 (odd?$ (sub1 n) c))))
; Signature: odd?$(n, c)
; Type: [Number * [Boolean->T1] -> T1]
; Purpose: Returns the application of the continuation c on true if the
; number n is odd, and the application of
; c on false otherwise.
(define odd?$
 (lambda (n c)
 (if (zero? n)
 (c #f)
 (even?$ (sub1 n) c))))
> (even?$ 6 id)
#t
× ×©×™× ×œ×‘: ×¢×œ ×©×ª×™ ×”×¤×•× ×§×¦×™×•×ª ×œ×”×™×•×ª ×›×ª×•×‘×•×ª ×‘×¦×•×¨×ª CPS .×× ×”×™×™× ×• ×ž×©×ª×ž×©×™× ×‘-$?even ×™×—×“ ×¢× odd ×©××™× ×” ×›×ª×•×‘×” ×›-
CPS( ×•×‘×”× ×—×” ×©-odd ×©×•×‘ ×§×•×¨××ª ×œ-$?even ,)×”×™×™× ×• "×–×•×¨×§×™×" ××ª ×”-continuation ×©×”×¦×˜×‘×¨ ×‘×›×œ ×¤×¢× ×©×”×™×™× ×• ×§×•×¨××™× ×œ-
$?even ×ž×ª×•×š odd( ×›×™×•×•×Ÿ ×©-odd ××™× ×” ×›×ª×•×‘×” ×‘×¦×•×¨×ª CPS ,×”×™× ××™× ×” ×ž×§×‘×œ×ª continuation ×›××¨×’×•×ž× ×˜ ×•×œ×›×Ÿ ×’× ×œ×
×ž×¢×‘×™×¨×” continuation.)
14
×©××œ×” 3 â€“ ×’×¨×¡×ª CPS ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×” ×œ×ž×¦×™××ª ×ž×—×œ×§ ×ž×©×•×ª×£ ×ž×§×¡×™×ž××œ×™ )gcd)
× ×ª×—×™×œ ×‘×‘×—×™× ×ª ×”×¤×¨×•×¦×“×•×¨×” ×‘×” ×ª×”×œ×™×š ×”×—×™×©×•×‘ ×”×•× ××™×˜×¨×˜×™×‘×™:
; Signature: gcd(n, m)
; Type: [Number * Number -> Number]
; Purpose: Returns the greatest common divider of n and m.
(define gcd
 (lambda (n m)
 (if (zero? m)
 n
 (gcd m (modulo n m)))))
15
×›×ª×™×‘×ª ×’×¨×¡×ª ×”-CPS ×”×™× ×ž×™×“×™×ª: ×”-continuation ×™×•×›×œ ×œ×”×™×©××¨ id( ×›×œ×•×ž×¨ ×œ×œ× ×©×™× ×•×™( ×œ××•×¨×š ×›×œ ×”×—×™×©×•×‘. ×–××ª, ×›×™×•×•×Ÿ ×©-n
×ž×©×ž×© ×›-"×¦×•×‘×¨" ×œ×ª×©×•×‘×” ×‘×ž×§×¨×” ×–×”. × ×‘×—×™×Ÿ ×›×™ ×œ×ž×¢×©×” ××™× × ×• ×ž×¨×—×™×‘×™× ××ª ×”×¤×•× ×§×¦×™×” "×”× ×©×œ×—×ª" ×› - continuation ×‘×ž×”×œ×š
×¨×™×¦×ª gcd:$
; Signature: gcd$(n, m)
; Type: [Number*Number*[Number->T1] -> T1]
; Purpose: Returns the application of the continuation
; c on the greatest common divider of n and m.
(define gcd$
 (lambda (n m c)
 (if (zero? m)
 (c n)
 (gcd$ m (modulo n m) c))))
> (gcd$ 6 9 sqr)
9
×©××œ×” 4 â€“ ×’×¨×¡×ª CPS ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×” ×œ×—×™×©×•×‘ ××•×¨×š ×¨×©×™×ž×”
× ×‘×—×Ÿ ×ª×—×™×œ×” ××ª ×”×ž×™×ž×•×© ×©×œ length ,×”×ž×—×©×‘×ª ××ª ××•×¨×›×” ×©×œ ×¨×©×™×ž×”:
; Signature: length(lst)
; Type: [List -> Number]
; Purpose: Returns the length of the list lst.
(define length
 (lambda (lst)
 (if (empty? lst)
 0
 (+ 1 (length (cdr lst))))))
> (length '(a b c d))
4
×•×‘×’×¨×¡×ª CPS:
; Signature: length$(lst, c)
; Type: [List*[Number->T1] -> T1]
; Purpose: Returns the application of the continuation
; c on the length of the list lst.
(define length$
 (lambda (lst c)
 (if (empty? lst)
 (c 0)
 (length$ (cdr lst)
 (lambda (cdr-length)
 (c (+ cdr-length 1)))))))
> (length$ '(a b c d) id)
4
×”×¨×¢×™×•×Ÿ ×”×•× ×œ×”× ×™×— ×›×™ ××œ ×”×ž×©×ª× ×” length-cdr" ×™×•×›× ×¡" ×”××•×¨×š ×©×œ ×–× ×‘ ×”×¨×©×™×ž×” )×–××ª ×›×™×•×•×Ÿ ×©×§×¨×× ×• ×¨×§×•×¨×¡×™×‘×™×ª ×œ×¤×•× ×§×¦×™×”
$length ×¢× )lst cdr .))×›×œ×•×ž×¨ ×× ×• ×ž× ×™×—×™× ×›×™ length-cdr ×—×•×©×‘ ×•×›×œ ×©× ×•×ª×¨ ×”×•× ×œ×”×¤×¢×™×œ ××ª ×”-continuation ×¢×œ ×”×ª×•×¦××”
×©×”×™× ××•×¨×š ×”×¨×©×™×ž×” ×›×•×œ×” )××•×¨×š ×–× ×‘ ×”×¨×©×™×ž×” + 1 .)× ×‘×—×™×Ÿ ×›×™ ×‘×›×œ ×©×œ×‘ ×‘××™×˜×¨×¦×™×” × ×•×¦×¨×ª ×¤×•× ×§×¦×™×™×ª continuation ×—×“×©×”
)×ž×•×¨×—×‘×ª( ×¤×¨×˜ ×œ×©×œ×‘ ×”××—×¨×•×Ÿ )×ž×§×¨×” ×”×‘×¡×™×¡(.
× ×©×™× ×œ×‘: ×”×©×™×ž×•×© ×‘-CPS ××™× ×• ×—×•×¡×š ×‘××•×¤×Ÿ ×›×œ×œ×™ ××ª ×”×–×™×›×¨×•×Ÿ ×”× ×“×¨×©, ××œ× ×¨×§ ×—×•×¡×š ××ª ×”×©×™×ž×•×© ×‘×ž×§×•× ×¢×œ ×”×ž×—×¡× ×™×ª.
×œ×ž×¢×©×”, ×”×¢×‘×¨× ×• ××ª ×”×©×™×ž×•×© ×‘×–×™×›×¨×•×Ÿ ×‘×›×œ ××™×˜×¨×¦×™×” ×ž×Ÿ ×”×ž×—×¡× ×™×ª ××œ ×”-heap( ×”-continuations ×”× closures ×•×”× ×ž×™×•×¦×¨×™×
×¢×œ ×”-heap .)
16
×©××œ×” 5 â€“ ×’×¨×¡×ª CPS ×¢×‘×•×¨ ×¤×¨×•×¦×“×•×¨×•×ª ×ž×¡×“×¨ ×’×‘×•×” )$$map)
; Signature: map(f, lst)
; Type: [[T1->T2] * List(T1) -> List(T2)]
; Purpose: Returns the list that results of applying
; f to the members of lst.
; Example: (map - '(1 2 3 4 5)) => '(-1 -2 -3 -4 -5)
(define map
 (lambda (f lst)
 (if (empty? lst)
 lst
 (cons (f (car lst)) (map f (cdr lst))))))
×× ×× ×• ×ž× ×™×—×™× ×›×™ ×¤×¨×•×¦×“×•×¨×•×ª ×”×ž×™×¤×•×™ f ×”×ž×ª×§×‘×œ×ª ×›××¨×’×•×ž× ×˜ ×”×™× ×¤×¨×™×ž×™×˜×™×‘×™×ª )×•××™× ×” ×›×ª×•×‘×” ×‘×¦×•×¨×ª CPS:)
; Signature: map$(f, lst, c)
; Type: [ [T1->T2] * List(T1) * [List(T2)->T3] -> T3 ]
; Purpose: Returns the application of the continuation c on the list
; that results of applying f to all the members of lst.
(define map$
 (lambda (f lst c)
 (if (empty? lst)
 (c lst)
 (map$ f (cdr lst)
 (lambda (mapped-cdr)
 (c (cons (f (car lst)) mapped-cdr)))))))
> (map$ - '(1 2 3 4 5) reverse)
'(-5 -4 -3 -2 -1)
.(cons (f (car lst)) mapped-cdr) ×¢×œ c ××ª ×”×¤×¢×œ× ×•, CPS ×‘×’×¨×¡×ª ×›×ª×•×‘×” ××™× ×” f ×©×”×¤×¨×•×¦×“×•×¨×” ×›×™×•×•×Ÿ
×›×¢×ª, × × ×™×— ×›×™ f ××™× ×” ×¤×¨×™×ž×™×˜×™×‘×™×ª, ×•×œ×›×Ÿ ×”×•×ž×¨×” ×œ×’×¨×¡×ª ×” CPS ×©×œ×”, $f .× ×¨××” ×›×™×¦×“ ×œ×›×ª×•×‘ ××ª ×’×¨×¡×ª ×”- CPS ×©×œ map ,
×›××©×¨ ×”×¤×¨×•×¦×“×•×¨×” ××•×ª×” ×ž×¤×¢×™×œ×™× ×¢×œ ×›×œ ××—×“ ×ž××™×‘×¨×™ ×”×¨×©×™×ž×”, $f ,× ×ª×•× ×” ×‘×¢×¦×ž×” ×‘×’×¨×¡×ª CPS:
; Signature: map$$(f$, lst, c)
; Type: [ [T1 * [T2->T3] -> T3] * List(T1) * [List(T3)->T4] -> T4 ]
; Purpose: Returns the application of the continuation c on
; the list that results of applying f to all the
; members of lst from the end to the start
(define map$$
 (lambda (f$ lst c)
 (if (empty? lst)
 (c lst)
 (map$$ f$
 (cdr lst)
 (lambda (mapped-cdr)
 (f$ (car lst)
 (lambda (mapped-car)
 (c (cons mapped-car mapped-cdr)))))))))
> (map$$ sqr$ '(1 2 3 4 5) id)
'(1 4 9 16 25)
17
× ×ª×‘×•× ×Ÿ ×‘-continuation ×©× ×‘× ×” ×œ××•×¨×š ×”×—×™×©×•×‘:
(map$$ sqr$ '(1 2) id )
(map$$ sqr$
 '(2)
 (lambda (mapped-cdr)
 (sqr$ 1
 (lambda (mapped-car)
 (id (cons mapped-car mapped-cdr))))) )

(map$$ sqr$
 '()
 (lambda (mapped-cdr)
 (sqr$ 2
 (lambda (mapped-car)
 ((lambda (mapped-cdr1)
 (sqr$ 1
 (lambda (mapped-car1)
 (id (cons mapped-car1 mapped-cdr1)))))
 (cons mapped-car mapped-cdr))))))
$$map ×ž×¤×¢×™×œ×” ××ª $f ×¢×œ ××‘×¨×™ ×”×¨×©×™×ž×” ×ž×”×¡×•×£ ×œ×”×ª×—×œ×” )×‘×“×•×’×ž×” 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 .)×”×¤×¢×œ×ª f ×•×”×§×¨×™××” ×œ-map
××™× ×Ÿ ×ª×œ×•×™×•×ª )××™× ×Ÿ ×ž×§×•× × ×•×ª ×–×• ×‘×–×•( ×•×œ×›×Ÿ × ×™×ª×Ÿ ×œ×‘×—×•×¨ ×ž×” ×™×ª×¨×—×© ×§×•×“× ×‘×’×¨×¡×ª ×” CPS .×›×š × ×§×‘×¢ ××ª ×”×¡×“×¨ ×‘×• ×ª×•×¤×¢×œ $f ×¢×œ
××‘×¨×™ ×”×¨×©×™×ž×” )×ž×”×”×ª×—×œ×” ×œ×¡×•×£ ××• ×œ×”×™×¤×š(. ×”×’×¨×¡×” ×”×‘××” ×ž×¤×¢×™×œ×” ××ª $f ×¢×œ ××‘×¨×™ ×”×¨×©×™×ž×” ×œ×¤×™ ×”×¡×“×¨ ×”×¨×’×™×œ ×©×œ ×ž×”×”×ª×—×œ×”
×œ×¡×•×£:
(define map$$
 (lambda (f$ lst c)
 (if (empty? lst)
 (c lst)
 (map$$ f$
 (car lst)
 (lambda (mapped-cdr)
 (f$ (cdr lst)
 (lambda (mapped-car)
 (c (cons mapped-car mapped-cdr)))))))))
> (map$$ sqr$ '(1 2 3 4 5) id)
'(1 4 9 16 25)


